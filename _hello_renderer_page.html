<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>Fermat: Hello Renderer!</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">
    (function(i, s, o, g, r, a, m) {
        i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function() {
            (i[r].q = i[r].q || []).push(arguments)
        }, i[r].l = 1 * new Date(); a = s.createElement(o),
  m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
    })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');
    ga('create', 'UA-47310325-1', 'nvlabs.github.io');
    ga('send', 'pageview');
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Fermat
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Hello Renderer! </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Top: <a class="el" href="_overture_contents_page.html">Contents</a></p>
<dl class="section user"><dt></dt><dd>We can now go on to writing our first "Hello World" renderer in Fermat. We'll start step-by-step with a renderer that implements some basic path tracing. </dd></dl>
<dl class="section user"><dt></dt><dd>Let's start from the class definition: <br />
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;renderer_interface.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;buffers.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;tiled_sequence.h&gt;</span></div><div class="line"></div><div class="line"><a href="#Options_Declaration_anchor">&lt;&lt; Options Declaration &gt;&gt;</a></div><div class="line"></div><div class="line"><span class="comment">// A &quot;Hello Path Tracing&quot; renderer</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">struct </span><a class="code" href="struct_hello_p_t.html">HelloPT</a> : <a class="code" href="struct_renderer_interface.html">RendererInterface</a></div><div class="line">{</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="struct_hello_p_t.html#a8ec59e3fac8eff801cecdd3220cd8d41">init</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv, <a class="code" href="struct_rendering_context.html">RenderingContext</a>&amp; renderer);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="struct_hello_p_t.html#af772aac0d80118742450fd8b6b3c58c2">render</a>(<span class="keyword">const</span> uint32 instance, <a class="code" href="struct_rendering_context.html">RenderingContext</a>&amp; renderer);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="struct_hello_p_t.html#ac81e09dcfb28dffc85aa6c4df06a4426">destroy</a>() { <span class="keyword">delete</span> <span class="keyword">this</span>; }</div><div class="line"></div><div class="line">    <a href="#Members_Declaration_anchor">&lt;&lt; Members Declaration &gt;&gt;</a></div><div class="line">};</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>So far, there should be hardly any surprises. We simply derived our class from the <a class="el" href="struct_renderer_interface.html">RendererInterface</a>, and declared that we'll implement both its <a class="el" href="struct_renderer_interface.html#a2ead9b943d6d48fcd32872e0005ebe63">RendererInterface::init()</a> and <a class="el" href="struct_renderer_interface.html#aa64254dd44c94929b05092dc8d74f29d">RendererInterface::render()</a> methods. Our renderer will also have some options, which we'll pack into a simple struct: <br />
<a class="anchor" id="Options_Declaration_anchor"></a> <blockquote class="doxtable">
<p><em> <a href="#Options_Declaration_anchor">&lt;&lt; Options Declaration &gt;&gt;</a> := </em></p>
<p></p>
</blockquote>
<div class="fragment"><div class="line"><span class="comment">// our &quot;Hello Path Tracing&quot; options</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">struct </span><a class="code" href="struct_hello_p_t_options.html">HelloPTOptions</a></div><div class="line">{</div><div class="line">     uint32 max_path_length;</div><div class="line"></div><div class="line">    <span class="comment">// default constructor</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <a class="code" href="struct_hello_p_t_options.html#a244c96683d3c5d345bdf4b6b8aa9c249">HelloPTOptions</a>() : max_path_length(6) {}</div><div class="line"></div><div class="line">    <span class="comment">// do some simple option parsing</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="struct_hello_p_t_options.html#a540d006dee6aff8ee5e8b3cfc8b0fa0b">parse</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; argc; ++i)</div><div class="line">        {</div><div class="line">         <span class="keywordflow">if</span> (strcmp(argv[i], <span class="stringliteral">&quot;-path-length&quot;</span>) == 0)</div><div class="line">             max_path_length = atoi(argv[++i]);</div><div class="line">        }</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>Now, we are ready to declare the members of our class: its options, some device memory buffer to hold temporary data, and a sampling sequence. <br />
<a class="anchor" id="Members_Declaration_anchor"></a> <blockquote class="doxtable">
<p><em> <a href="#Members_Declaration_anchor">&lt;&lt; Members Declaration &gt;&gt;</a> := </em></p>
<p></p>
</blockquote>
<div class="fragment"><div class="line"><a class="code" href="struct_hello_p_t_options.html">HelloPTOptions</a>                      m_options;      <span class="comment">// the rendering options</span></div><div class="line"><a class="code" href="class_domain_buffer.html">DomainBuffer&lt;CUDA_BUFFER, uint8&gt;</a>    m_memory_pool;  <span class="comment">// some device storage for queues and such...</span></div><div class="line"><a class="code" href="struct_tiled_sequence.html">TiledSequence</a>                       m_sequence;     <span class="comment">// a nice sampling sequence</span></div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>Once the declaration is ready, we can start with the definition of the init method: <br />
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="struct_hello_p_t.html#a8ec59e3fac8eff801cecdd3220cd8d41">HelloPT::init</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv, <a class="code" href="struct_rendering_context.html">RenderingContext</a>&amp; renderer)</div><div class="line">{</div><div class="line">    <a href="#Parse_options_anchor">&lt;&lt; Parse options &gt;&gt;</a></div><div class="line">    <a href="#Alloc_queue_storage_anchor">&lt;&lt; Alloc queue storage &gt;&gt;</a></div><div class="line">    <a href="#Initialize_sampler_anchor">&lt;&lt; Initialize sampler &gt;&gt;</a></div><div class="line">    <a href="#Initialize_mesh_lights_anchor">&lt;&lt; Initialize mesh lights &gt;&gt;</a></div><div class="line">}</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>Parsing options is straightforward: <br />
<a class="anchor" id="Parse_options_anchor"></a> <blockquote class="doxtable">
<p><em> <a href="#Parse_options_anchor">&lt;&lt; Parse options &gt;&gt;</a> := </em></p>
<p></p>
</blockquote>
<div class="fragment"><div class="line"><span class="comment">// parse the options</span></div><div class="line">m_options.<a class="code" href="struct_hello_p_t_options.html#a540d006dee6aff8ee5e8b3cfc8b0fa0b">parse</a>( argc, argv );</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>The next step is allocating all temporary storage we'll need. Our renderer will be organized as a pipeline of separate ray tracing and shading stages, implemented as parallel kernels communicating through global memory queues. In order to simplify our life we'll make use of some prepackaged queue definition provided by Fermat, the <a class="el" href="struct_p_t_ray_queue.html">PTRayQueue</a>. These queues are defined by an array of rays, an array of ray hits, an array of sample weights associated to each ray, and finally an array of pixel descriptors. For reasons that will be explained later on, we'll need three such queues, and each of them will need to contain enough storage for as many pixels there are in our target framebuffer. <br />
<a class="anchor" id="Alloc_queue_storage_anchor"></a> <blockquote class="doxtable">
<p><em> <a href="#Alloc_queue_storage_anchor">&lt;&lt; Alloc queue storage &gt;&gt;</a> := </em></p>
<p></p>
</blockquote>
<div class="fragment"><div class="line"><span class="comment">// pre-alloc some queue storage</span></div><div class="line">{</div><div class="line">    <span class="comment">// keep track of how much storage we&#39;ll need</span></div><div class="line">    <a class="code" href="structcugar_1_1memory__arena.html">cugar::memory_arena</a> arena;</div><div class="line"></div><div class="line">    <a class="code" href="struct_p_t_ray_queue.html">PTRayQueue</a> input_queue;</div><div class="line">    <a class="code" href="struct_p_t_ray_queue.html">PTRayQueue</a> scatter_queue;</div><div class="line">    <a class="code" href="struct_p_t_ray_queue.html">PTRayQueue</a> shadow_queue;</div><div class="line">     </div><div class="line">    <a class="code" href="group___p_t_lib.html#gaf8daef8b815f7712ff692edbaa628881">alloc_queues</a>( n_pixels, input_queue, scatter_queue, shadow_queue, arena );</div><div class="line"></div><div class="line">    fprintf(stderr, <span class="stringliteral">&quot;  allocating queue storage: %.1f MB\n&quot;</span>, <span class="keywordtype">float</span>(arena.size) / (1024*1024));</div><div class="line">    m_memory_pool.alloc(arena.size);</div><div class="line">}</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>where <a class="el" href="group___p_t_lib.html#gaf8daef8b815f7712ff692edbaa628881">alloc_queues()</a> is a utility function defined as: <br />
 <div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="group___p_t_lib.html#gaf8daef8b815f7712ff692edbaa628881">alloc_queues</a>(</div><div class="line">    <span class="keyword">const</span> uint32            n_pixels,</div><div class="line">    <a class="code" href="struct_p_t_ray_queue.html">PTRayQueue</a>&amp;             input_queue,</div><div class="line">    <a class="code" href="struct_p_t_ray_queue.html">PTRayQueue</a>&amp;             scatter_queue,</div><div class="line">    <a class="code" href="struct_p_t_ray_queue.html">PTRayQueue</a>&amp;             shadow_queue,</div><div class="line">    <a class="code" href="structcugar_1_1memory__arena.html">cugar::memory_arena</a>&amp;    arena)</div><div class="line">{   </div><div class="line">    input_queue.rays        = arena.<a class="code" href="structcugar_1_1memory__arena.html#afcbc6673ae3fa3e61368495ed2041621">alloc</a>&lt;<a class="code" href="struct_masked_ray.html">MaskedRay</a>&gt;(n_pixels);</div><div class="line">    input_queue.hits        = arena.<a class="code" href="structcugar_1_1memory__arena.html#afcbc6673ae3fa3e61368495ed2041621">alloc</a>&lt;<a class="code" href="struct_hit.html">Hit</a>&gt;(n_pixels);</div><div class="line">    input_queue.weights     = arena.<a class="code" href="structcugar_1_1memory__arena.html#afcbc6673ae3fa3e61368495ed2041621">alloc</a>&lt;float4&gt;(n_pixels);</div><div class="line">    input_queue.pixels      = arena.<a class="code" href="structcugar_1_1memory__arena.html#afcbc6673ae3fa3e61368495ed2041621">alloc</a>&lt;uint4&gt;(n_pixels);</div><div class="line">    input_queue.size        = arena.<a class="code" href="structcugar_1_1memory__arena.html#afcbc6673ae3fa3e61368495ed2041621">alloc</a>&lt;uint32&gt;(1);</div><div class="line"></div><div class="line">    scatter_queue.rays      = arena.<a class="code" href="structcugar_1_1memory__arena.html#afcbc6673ae3fa3e61368495ed2041621">alloc</a>&lt;<a class="code" href="struct_masked_ray.html">MaskedRay</a>&gt;(n_pixels);</div><div class="line">    scatter_queue.hits      = arena.<a class="code" href="structcugar_1_1memory__arena.html#afcbc6673ae3fa3e61368495ed2041621">alloc</a>&lt;<a class="code" href="struct_hit.html">Hit</a>&gt;(n_pixels);</div><div class="line">    scatter_queue.weights   = arena.<a class="code" href="structcugar_1_1memory__arena.html#afcbc6673ae3fa3e61368495ed2041621">alloc</a>&lt;float4&gt;(n_pixels);</div><div class="line">    scatter_queue.pixels    = arena.<a class="code" href="structcugar_1_1memory__arena.html#afcbc6673ae3fa3e61368495ed2041621">alloc</a>&lt;uint4&gt;(n_pixels);</div><div class="line">    scatter_queue.size      = arena.<a class="code" href="structcugar_1_1memory__arena.html#afcbc6673ae3fa3e61368495ed2041621">alloc</a>&lt;uint32&gt;(1);</div><div class="line"></div><div class="line">    shadow_queue.rays       = arena.<a class="code" href="structcugar_1_1memory__arena.html#afcbc6673ae3fa3e61368495ed2041621">alloc</a>&lt;<a class="code" href="struct_masked_ray.html">MaskedRay</a>&gt;(n_pixels);</div><div class="line">    shadow_queue.hits       = arena.<a class="code" href="structcugar_1_1memory__arena.html#afcbc6673ae3fa3e61368495ed2041621">alloc</a>&lt;<a class="code" href="struct_hit.html">Hit</a>&gt;(n_pixels);</div><div class="line">    shadow_queue.weights    = arena.<a class="code" href="structcugar_1_1memory__arena.html#afcbc6673ae3fa3e61368495ed2041621">alloc</a>&lt;float4&gt;(n_pixels);</div><div class="line">    shadow_queue.pixels     = arena.<a class="code" href="structcugar_1_1memory__arena.html#afcbc6673ae3fa3e61368495ed2041621">alloc</a>&lt;uint4&gt;(n_pixels);</div><div class="line">    shadow_queue.size       = arena.<a class="code" href="structcugar_1_1memory__arena.html#afcbc6673ae3fa3e61368495ed2041621">alloc</a>&lt;uint32&gt;(1);</div><div class="line">}</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>Similarly, for sampling we'll use the <a class="el" href="struct_tiled_sequence.html">TiledSequence</a> class, considering that we will need to allocate up to 6 random numbers per path vertex: <br />
<a class="anchor" id="Initialize_sampler_anchor"></a> <blockquote class="doxtable">
<p><em> <a href="#Initialize_sampler_anchor">&lt;&lt; Initialize sampler &gt;&gt;</a> := </em></p>
<p></p>
</blockquote>
<div class="fragment"><div class="line"><span class="comment">// build the set of samples assuming 6 random numbers per path vertex and a tile size of 256 pixels</span></div><div class="line"><span class="keyword">const</span> uint32 n_dimensions = 6 * (m_options.max_path_length + 1);</div><div class="line"><span class="keyword">const</span> uint32 tile_size    = 256;</div><div class="line">fprintf(stderr, <span class="stringliteral">&quot;  initializing sampler: %u dimensions\n&quot;</span>, n_dimensions);</div><div class="line">m_sequence.setup(n_dimensions, tile_size);</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>And finally, we'll have to initialize our mesh light sampler: <br />
<a class="anchor" id="Initialize_mesh_lights_anchor"></a> <blockquote class="doxtable">
<p><em> <a href="#Initialize_mesh_lights_anchor">&lt;&lt; Initialize mesh lights &gt;&gt;</a> := </em></p>
<p></p>
</blockquote>
<div class="fragment"><div class="line"><span class="comment">// initialize the mesh lights sampler</span></div><div class="line">renderer.m_mesh_lights.<a class="code" href="struct_rendering_context.html#a5ca766a70c2def1699f2ed6fa1f8bccd">init</a>( n_pixels, renderer );</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>Now that we have covered initialization, we can move on the definition of the render() method. We'll start by defining a context class that will be passed down to our device kernels. This class will encapsulate the renderer state, including views of the sampler, queues and so on. <br />
<div class="fragment"><div class="line"><span class="keyword">struct </span>HelloPTContext</div><div class="line">{</div><div class="line">    <a class="code" href="struct_hello_p_t_options.html">HelloPTOptions</a>       options;        <span class="comment">// the options</span></div><div class="line">    <a class="code" href="struct_tiled_sequence_view.html">TiledSequenceView</a>    sequence;       <span class="comment">// the sampling sequence</span></div><div class="line">    <span class="keywordtype">float</span>                frame_weight;   <span class="comment">// the weight given to samples in this frame</span></div><div class="line">    uint32               in_bounce;      <span class="comment">// the current path tracing bounce</span></div><div class="line"></div><div class="line">    <a class="code" href="struct_p_t_ray_queue.html">PTRayQueue</a>           in_queue;       <span class="comment">// the input queue</span></div><div class="line">    <a class="code" href="struct_p_t_ray_queue.html">PTRayQueue</a>           shadow_queue;   <span class="comment">// the scattering queue</span></div><div class="line">    <a class="code" href="struct_p_t_ray_queue.html">PTRayQueue</a>           scatter_queue;  <span class="comment">// the shadow queue</span></div><div class="line">};</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>At this point we can start sketching the main rendering algorithm. The idea is that, after some proper initializations, we'll generate primary rays and enqueue them to the input queue, and then start executing a pipeline, where we: </dd></dl>
<dl class="section user"><dt></dt><dd><ol type="1">
<li>trace rays</li>
<li>shade the ray hits (i.e. the new path vertices), potentially generating new shadow and scattering rays</li>
<li>trace any queued shadow rays</li>
<li>shade the shadow hits</li>
<li>and swap the input and scattering queues</li>
</ol>
</dd></dl>
<dl class="section user"><dt></dt><dd>which in code becomes: <br />
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="struct_hello_p_t.html#af772aac0d80118742450fd8b6b3c58c2">HelloPT::render</a>(<span class="keyword">const</span> uint32 instance, <a class="code" href="struct_rendering_context.html">RenderingContext</a>&amp; renderer)</div><div class="line">{</div><div class="line">    <a href="#Perform_initializations_anchor">&lt;&lt; Perform initializations &gt;&gt;</a></div><div class="line"></div><div class="line">    <a href="#Generate_primary_rays_anchor">&lt;&lt; Generate primary rays &gt;&gt;</a></div><div class="line"></div><div class="line">    <span class="comment">// start the path tracing loop</span></div><div class="line">    <span class="keywordflow">while</span> (1)</div><div class="line">    {</div><div class="line">        <a href="#Check_input_queue_size_and_possibly_bail-out_anchor">&lt;&lt; Check input queue size and possibly bail-out &gt;&gt;</a></div><div class="line"></div><div class="line">        <a href="#Trace_rays_inside_the_input_queue_anchor">&lt;&lt; Trace rays inside the input queue &gt;&gt;</a>  </div><div class="line"></div><div class="line">        <a href="#Clear_the_scattering_and_shadow_queues_anchor">&lt;&lt; Clear the scattering and shadow queues &gt;&gt;</a></div><div class="line"></div><div class="line">        <a href="#Shade_ray_hits_anchor">&lt;&lt; Shade ray hits &gt;&gt;</a></div><div class="line"></div><div class="line">        <a href="#Trace_and_shade_shadow_rays_anchor">&lt;&lt; Trace and shade shadow rays &gt;&gt;</a></div><div class="line"></div><div class="line">        <a href="#Swap_the_intput_and_scattering_queues_anchor">&lt;&lt; Swap the intput and scattering queues &gt;&gt;</a></div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>Initializations are fairly trivial: we need to really allocate the queues out of the pre-allocated memory pool, initialize the sampling sequence, setup our context, and finally rescale the render targets containing results up to frame <em>instance</em> by a factor of <em>instance / (instance + 1)</em>, for blending in the new one: <br />
<a class="anchor" id="Perform_initializations_anchor"></a> <blockquote class="doxtable">
<p><em> <a href="#Perform_initializations_anchor">&lt;&lt; Perform initializations &gt;&gt;</a> := </em></p>
<p></p>
</blockquote>
<div class="fragment"><div class="line"><span class="keyword">const</span> uint2 res = renderer.<a class="code" href="struct_rendering_context.html#ad1a58510bdaf6f373080835abf5db2db">res</a>();</div><div class="line"></div><div class="line"><span class="keyword">const</span> uint32 n_pixels = res.x * res.y;</div><div class="line"></div><div class="line"><span class="comment">// carve an arena out of our pre-allocated memory pool</span></div><div class="line"><a class="code" href="structcugar_1_1memory__arena.html">cugar::memory_arena</a> arena( m_memory_pool.ptr() );</div><div class="line"></div><div class="line"><span class="comment">// alloc all the queues</span></div><div class="line"><a class="code" href="struct_p_t_ray_queue.html">PTRayQueue</a> in_queue;</div><div class="line"><a class="code" href="struct_p_t_ray_queue.html">PTRayQueue</a> scatter_queue;</div><div class="line"><a class="code" href="struct_p_t_ray_queue.html">PTRayQueue</a> shadow_queue;</div><div class="line"></div><div class="line"><a class="code" href="group___p_t_lib.html#gaf8daef8b815f7712ff692edbaa628881">alloc_queues</a>(</div><div class="line">    n_pixels,</div><div class="line">    in_queue,</div><div class="line">    scatter_queue,</div><div class="line">    shadow_queue,</div><div class="line">    arena );</div><div class="line"></div><div class="line"><span class="comment">// fetch a view of the renderer</span></div><div class="line"><a class="code" href="struct_rendering_context_view.html">RenderingContextView</a> renderer_view = renderer.<a class="code" href="struct_rendering_context.html#a591062fd1887b069a015ede456dcaa93">view</a>(instance);</div><div class="line"></div><div class="line"><span class="comment">// fetch the ray tracing context</span></div><div class="line"><a class="code" href="struct_r_t_context.html">RTContext</a>* rt_context = renderer.<a class="code" href="struct_rendering_context.html#af12ae90cc453d139f6f8ae35791e6563">get_rt_context</a>();</div><div class="line"></div><div class="line"><span class="comment">// setup the samples for this frame</span></div><div class="line">m_sequence.set_instance(instance);</div><div class="line"></div><div class="line"><span class="comment">// setup our context</span></div><div class="line">HelloPTContext context;</div><div class="line">context.options       = m_options;</div><div class="line">context.sequence      = m_sequence.view();</div><div class="line">context.frame_weight  = 1.0f / (instance + 1);</div><div class="line">context.in_queue      = in_queue;</div><div class="line">context.scatter_queue = scatter_queue;</div><div class="line">context.shadow_queue  = shadow_queue;</div><div class="line"></div><div class="line"><span class="comment">// rescale the previous render targets for blending/averaging in the new one</span></div><div class="line">    renderer.<a class="code" href="struct_rendering_context.html#a6fb940a3b78a8a3faf82676c95ab1e6f">rescale_frame</a>( instance );</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>In order to generate primary rays, we assume we have some kernel already available and a function to dispatch it: <br />
<a class="anchor" id="Generate_primary_rays_anchor"></a> <blockquote class="doxtable">
<p><em> <a href="#Generate_primary_rays_anchor">&lt;&lt; Generate primary rays &gt;&gt;</a> := </em></p>
<p></p>
</blockquote>
<div class="fragment"><div class="line"><span class="comment">// generate the primary rays</span></div><div class="line"><a class="code" href="group___p_t_lib.html#ga66602a846711dc021ed0b930846ea596">generate_primary_rays</a>(context, renderer_view);</div><div class="line">CUDA_CHECK(cugar::cuda::sync_and_check_error(<span class="stringliteral">&quot;generate primary rays&quot;</span>));</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>Now, we can start tackling the inner loop. Checking the size of the input queue is just a matter of copying the value of the queue's size field to the host: <br />
<a class="anchor" id="Check_input_queue_size_and_possibly_bail-out_anchor"></a> <blockquote class="doxtable">
<p><em> <a href="#Check_input_queue_size_and_possibly_bail-out_anchor">&lt;&lt; Check input queue size and possibly bail-out &gt;&gt;</a> := </em></p>
<p></p>
</blockquote>
<div class="fragment"><div class="line">uint32 in_queue_size;</div><div class="line"></div><div class="line"><span class="comment">// fetch the amount of tasks in the queue</span></div><div class="line">cudaMemcpy(&amp;in_queue_size, context.in_queue.size, <span class="keyword">sizeof</span>(uint32), cudaMemcpyDeviceToHost);</div><div class="line"></div><div class="line"><span class="comment">// check whether there&#39;s still any work left</span></div><div class="line"><span class="keywordflow">if</span> (in_queue_size == 0)</div><div class="line">    <span class="keywordflow">break</span>;</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>while tracing the rays can be done with a single RTContext::trace() call: <br />
<a class="anchor" id="Trace_rays_inside_the_input_queue_anchor"></a> <blockquote class="doxtable">
<p><em> <a href="#Trace_rays_inside_the_input_queue_anchor">&lt;&lt; Trace rays inside the input queue &gt;&gt;</a> := </em></p>
<p></p>
</blockquote>
<div class="fragment"><div class="line"><span class="comment">// trace the rays generated at the previous bounce</span></div><div class="line"><span class="comment">//</span></div><div class="line">rt_context-&gt;trace(in_queue_size, (<a class="code" href="struct_ray.html">Ray</a>*)context.in_queue.rays, context.in_queue.hits);</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>This step will generate a bunch of ray hit points, i.e. all we need to reconstruct the next wave of path vertices. Before we proceed to shading them, we'll have to clear the sizes of the shadow and scattering queues - again, just a matter of performing a memset in device memory: <br />
<a class="anchor" id="Clear_the_scattering_and_shadow_queues_anchor"></a> <blockquote class="doxtable">
<p><em> <a href="#Clear_the_scattering_and_shadow_queues_anchor">&lt;&lt; Clear the scattering and shadow queues &gt;&gt;</a> := </em></p>
<p></p>
</blockquote>
<div class="fragment"><div class="line"><span class="comment">// reset the output queue counters</span></div><div class="line">cudaMemset(context.shadow_queue.size, 0x00, <span class="keyword">sizeof</span>(uint32));</div><div class="line">cudaMemset(context.scatter_queue.size, 0x00, <span class="keyword">sizeof</span>(uint32));</div><div class="line">CUDA_CHECK(cugar::cuda::check_error(<span class="stringliteral">&quot;memset&quot;</span>));</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>Finally, we can proceed to shade the new path vertices, trace any shadow rays that their shading might have generated, and finally swap the input and scattering queues. For this, we'll assume two more functions exist, <a class="el" href="_hello_renderer_page.html#shade_vertices_anchor">shade_vertices()</a> and <a class="el" href="_hello_renderer_page.html#resolve_occlusion_anchor">resolve_occlusion()</a>. <br />
<a class="anchor" id="Shade_ray_hits_anchor"></a> <blockquote class="doxtable">
<p><em> <a href="#Shade_ray_hits_anchor">&lt;&lt; Shade ray hits &gt;&gt;</a> := </em></p>
<p></p>
</blockquote>
<div class="fragment"><div class="line"><span class="comment">// perform lighting at this bounce</span></div><div class="line"><span class="comment">//</span></div><div class="line">shade_vertices(in_queue_size, context, renderer_view);</div><div class="line">CUDA_CHECK(cugar::cuda::sync_and_check_error(<span class="stringliteral">&quot;shade hits&quot;</span>));</div></div><!-- fragment --> <a class="anchor" id="Trace_and_shade_shadow_rays_anchor"></a> <blockquote class="doxtable">
<p><em> <a href="#Trace_and_shade_shadow_rays_anchor">&lt;&lt; Trace and shade shadow rays &gt;&gt;</a> := </em></p>
<p></p>
</blockquote>
<div class="fragment"><div class="line"><span class="comment">// trace &amp; accumulate occlusion queries</span></div><div class="line">{</div><div class="line">    <span class="comment">// fetch the amount of tasks in the queue</span></div><div class="line">    uint32 shadow_queue_size;</div><div class="line">    cudaMemcpy(&amp;shadow_queue_size, context.shadow_queue.size, <span class="keyword">sizeof</span>(uint32), cudaMemcpyDeviceToHost);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (shadow_queue_size)</div><div class="line">    {</div><div class="line">        <span class="comment">// trace the rays</span></div><div class="line">        <span class="comment">//</span></div><div class="line">        rt_context-&gt;trace_shadow(shadow_queue_size, (<a class="code" href="struct_masked_ray.html">MaskedRay</a>*)context.shadow_queue.rays, context.shadow_queue.hits);</div><div class="line"></div><div class="line">        <span class="comment">// shade the results</span></div><div class="line">        <span class="comment">//</span></div><div class="line">        resolve_occlusion(shadow_queue_size, context, renderer_view);</div><div class="line">        CUDA_CHECK(cugar::cuda::sync_and_check_error(<span class="stringliteral">&quot;resolve occlusion&quot;</span>));</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> <a class="anchor" id="Swap_the_intput_and_scattering_queues_anchor"></a> <blockquote class="doxtable">
<p><em> <a href="#Swap_the_intput_and_scattering_queues_anchor">&lt;&lt; Swap the intput and scattering queues &gt;&gt;</a> := </em></p>
<p></p>
</blockquote>
<div class="fragment"><div class="line"><span class="comment">// swap the input and output queues</span></div><div class="line">std::swap(context.in_queue, context.scatter_queue);</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>At this point, we just need to fill in the missing details, and define the <a class="el" href="_hello_renderer_page.html#HelloPT-generate_primary_rays">generate_primary_rays()</a>, <a class="el" href="_hello_renderer_page.html#shade_vertices_anchor">shade_vertices()</a> and <a class="el" href="_hello_renderer_page.html#resolve_occlusion_anchor">resolve_occlusion()</a> kernels.</dd></dl>
<h1><a class="anchor" id="HelloPTGeneratingPrimaryRaysSection"></a>
Generating Primary Rays</h1>
<dl class="section user"><dt></dt><dd>Generating primary rays will require us to write a fairly simple kernel, and a function to dispatch it: <a class="anchor" id="HelloPT-generate_primary_rays"></a> <br />
 <div class="fragment"><div class="line"><span class="comment">// a kernel to generate the primary rays </span></div><div class="line"><span class="comment">//</span></div><div class="line">__global__</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="group___p_t_lib.html#ga9382084c986a4fe52d55f7f225211e66">generate_primary_rays_kernel</a>(</div><div class="line">    HelloPTContext          context,</div><div class="line">    <a class="code" href="struct_rendering_context_view.html">RenderingContextView</a>    renderer)</div><div class="line">{</div><div class="line">    <span class="comment">// calculate the 2d pixel index given from the thread id</span></div><div class="line">    <span class="keyword">const</span> uint2 pixel = make_uint2(</div><div class="line">        threadIdx.x + blockIdx.x*blockDim.x,</div><div class="line">        threadIdx.y + blockIdx.y*blockDim.y );</div><div class="line"></div><div class="line">    <span class="comment">// check whether the pixel/thread is inside the render target</span></div><div class="line">    <span class="keywordflow">if</span> (pixel.x &gt;= renderer.res_x || pixel.y &gt;= renderer.res_y)</div><div class="line">        <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">    <span class="comment">// calculate a 1d pixel index</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> idx = pixel.x + pixel.y*renderer.res_x;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="struct_masked_ray.html">MaskedRay</a> ray = <a class="code" href="group___p_t_lib_core.html#ga28fe33ab0663b2331fe607662ed07349">generate_primary_ray</a>( context, renderer, pixel );</div><div class="line"></div><div class="line">    <span class="comment">// write the output ray</span></div><div class="line">    context.in_queue.rays[idx] = ray;</div><div class="line"></div><div class="line">    <span class="comment">// write the path weight</span></div><div class="line">    context.in_queue.weights[idx] = <a class="code" href="structcugar_1_1_vector.html">cugar::Vector4f</a>(1.0f, 1.0f, 1.0f, 1.0f);</div><div class="line"></div><div class="line">    <span class="comment">// write the pixel index</span></div><div class="line">    context.in_queue.pixels[idx] = make_uint4( idx, uint32(-1), uint32(-1), uint32(-1) );</div><div class="line"></div><div class="line">    <span class="comment">// use thread 0 write out the total number of primary rays in the queue descriptor</span></div><div class="line">    <span class="keywordflow">if</span> (pixel.x == 0 &amp;&amp; pixel.y)</div><div class="line">        *context.in_queue.size = renderer.res_x * renderer.res_y;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// dispatch the generate_primary_rays kernel</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="group___p_t_lib.html#ga66602a846711dc021ed0b930846ea596">generate_primary_rays</a>(</div><div class="line">    HelloPTContext          context,</div><div class="line">    <a class="code" href="struct_rendering_context_view.html">RenderingContextView</a>    renderer)</div><div class="line">{</div><div class="line">    dim3 blockSize(32, 16);</div><div class="line">    dim3 gridSize(<a class="code" href="group___basic_utils.html#gabb6714186dbbd864f0a9298944ba509b">cugar::divide_ri</a>(renderer.res_x, blockSize.x), <a class="code" href="group___basic_utils.html#gabb6714186dbbd864f0a9298944ba509b">cugar::divide_ri</a>(renderer.res_y, blockSize.y));</div><div class="line">    generate_primary_rays_kernel &lt;&lt; &lt; gridSize, blockSize &gt;&gt; &gt; (context, renderer);</div><div class="line">}</div></div><!-- fragment --> </dd></dl>
<h1><a class="anchor" id="HelloPTShadingVerticesSection"></a>
Shading Vertices</h1>
<dl class="section user"><dt></dt><dd>We'll start from a single-threaded device function that will be called each time we process a vertex. This function will receive an incoming ray and a <a class="el" href="struct_hit.html">Hit</a> object, and use those to <em>reconstruct</em> a full path vertex. After the vertex is set up, it will proceed initializing the local sample sequence, performing next-event estimation, evaluating the local emission at the hit in the direction of the incoming ray, and finally evaluating any scattering/absorption events. <a class="anchor" id="shade_vertex_anchor"></a> <br />
<div class="fragment"><div class="line"><span class="comment">// shade a path vertex</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// \param pixel_index       the 1d pixel index associated with this path</span></div><div class="line"><span class="comment">// \param pixel             the 2d pixel coordinates</span></div><div class="line"><span class="comment">// \param ray               the incoming ray direction</span></div><div class="line"><span class="comment">// \param hit               the hit point defining this vertex</span></div><div class="line"><span class="comment">// \param w                 the current path weight</span></div><div class="line"><span class="comment">// \param p_prev            the solid angle probability of the last scattering event</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// \return                  true if the path is continued, false if it terminates here</span></div><div class="line">FERMAT_DEVICE</div><div class="line"><span class="keywordtype">bool</span> <a class="code" href="group___p_t_lib_core.html#ga9b8be237ade285e6db792a9ea7bf900e">shade_vertex</a>(</div><div class="line"> HelloPTContext&amp;         context,</div><div class="line"> <a class="code" href="struct_rendering_context_view.html">RenderingContextView</a>&amp;   renderer,</div><div class="line"> <span class="keyword">const</span> uint32            pixel_index,</div><div class="line"> <span class="keyword">const</span> uint2             pixel,</div><div class="line"> <span class="keyword">const</span> <a class="code" href="struct_masked_ray.html">MaskedRay</a>&amp;        ray,</div><div class="line"> <span class="keyword">const</span> <a class="code" href="struct_hit.html">Hit</a>               hit,</div><div class="line"> <span class="keyword">const</span> <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a>   w,</div><div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span>             p_prev)</div><div class="line">{</div><div class="line">    <span class="comment">// check if this is a valid hit</span></div><div class="line">    <span class="keywordflow">if</span> (hit.t &gt; 0.0f &amp;&amp; hit.triId &gt;= 0)</div><div class="line">    {</div><div class="line">        <a href="#Setup_path_vertex_anchor">&lt;&lt; Setup path vertex &gt;&gt;</a></div><div class="line">        <a href="#Write_out_G-buffer_on_primary_hits_anchor">&lt;&lt; Write out G-buffer on primary hits &gt;&gt;</a></div><div class="line">        <a href="#Initialize_sampling_sequence_anchor">&lt;&lt; Initialize sampling sequence &gt;&gt;</a></div><div class="line">        <a href="#Perform_Next-Event_Estimation_anchor">&lt;&lt; Perform Next-Event Estimation &gt;&gt;</a></div><div class="line">        <a href="#Evaluate_emissive_hits_anchor">&lt;&lt; Evaluate emissive hits &gt;&gt;</a></div><div class="line">        <a href="#Evaluate_scattering_and_absorption_anchor">&lt;&lt; Evaluate scattering and absorption &gt;&gt;</a></div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <a href="#Evaluate_sky-lighting_anchor">&lt;&lt; Evaluate sky-lighting &gt;&gt;</a></div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// this path terminates here</span></div><div class="line">}</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>In order to setup the vertex, we'll use Fermat's <a class="el" href="struct_eye_vertex.html">EyeVertex</a> class, an object representing a vertex sampled from the eye (i.e. using forward path tracing), which helps interpolating vertex attributes, keep tracking of the path sampling probabilities, setting up vertex <a class="el" href="struct_bsdf.html">Bsdf</a> (evaluating the material, including any textures), and so on. <br />
<a class="anchor" id="Setup_path_vertex_anchor"></a> <blockquote class="doxtable">
<p><em> <a href="#Setup_path_vertex_anchor">&lt;&lt; Setup path vertex &gt;&gt;</a> := </em></p>
<p></p>
</blockquote>
<div class="fragment"><div class="line"><span class="comment">// setup an eye-vertex given the input ray, hit point, and path weight</span></div><div class="line"><a class="code" href="struct_eye_vertex.html">EyeVertex</a> ev;</div><div class="line">ev.setup(ray, hit, w.xyz(), <a class="code" href="structcugar_1_1_vector.html">cugar::Vector4f</a>(0.0f), context.in_bounce, renderer);</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>Once we have all the vertex information, we can write out any G-buffer information on primary rays (i.e. when we are processing the zero-th bounce): <br />
<a class="anchor" id="Write_out_G-buffer_on_primary_hits_anchor"></a> <blockquote class="doxtable">
<p><em> <a href="#Write_out_G-buffer_on_primary_hits_anchor">&lt;&lt; Write out G-buffer on primary hits &gt;&gt;</a> := </em></p>
<p></p>
</blockquote>
<div class="fragment"><div class="line"><span class="comment">// write out gbuffer information</span></div><div class="line"><span class="keywordflow">if</span> (context.in_bounce == 0)</div><div class="line">{</div><div class="line">    renderer.fb.gbuffer.geo(pixel_index)   = GBufferView::pack_geometry(ev.geom.position, ev.geom.normal_s);</div><div class="line">    renderer.fb.gbuffer.uv(pixel_index)    = make_float4(hit.u, hit.v, ev.geom.texture_coords.x, ev.geom.texture_coords.y);</div><div class="line">    renderer.fb.gbuffer.tri(pixel_index)   = hit.triId;</div><div class="line">    renderer.fb.gbuffer.depth(pixel_index) = hit.t;</div><div class="line">}</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>Initializing the sampling coordinates requires fetching a batch 6 random numbers (3 for next-event estimation and 3 for scattering) from the <a class="el" href="struct_tiled_sequence_view.html">TiledSequenceView</a> sampling sequence, which again, can be done using a prepackaged utility function: <a class="el" href="group___p_t_lib_core.html#ga4881c06f23dccad0fc8972bda8de1b40">vertex_sample()</a> <br />
<a class="anchor" id="Initialize_sampling_sequence_anchor"></a> <blockquote class="doxtable">
<p><em> <a href="#Initialize_sampling_sequence_anchor">&lt;&lt; Initialize sampling sequence &gt;&gt;</a> := </em></p>
<p></p>
</blockquote>
<div class="fragment"><div class="line"><span class="comment">// initialize our shifted sampling sequence</span></div><div class="line"><span class="keywordtype">float</span> samples[6];</div><div class="line"><span class="keywordflow">for</span> (uint32 i = 0; i &lt; 6; ++i)</div><div class="line">    samples[i] = <a class="code" href="group___p_t_lib_core.html#ga4881c06f23dccad0fc8972bda8de1b40">vertex_sample</a>(pixel, context, i);</div></div><!-- fragment --></dd></dl>
<h2><a class="anchor" id="NextEventEstimationSection"></a>
Next-Event Estimation</h2>
<dl class="section user"><dt></dt><dd>Next-event estimation is trickier business. It will involve four basic steps: sampling a point on the light sources (in this case, the scene's mesh), evaluating the the EDF in the direction of the current vertex and the local BSDF in the direction joining the current vertex to the sampled point, calculating the sample weight, and finally enqueuing a shadow ray to check if the sample is occluded or visible. Notice that NEE essentially adds a vertex to a path, so if we allow a maximum path length of <em>N</em>, we can only perform it if our current path is shorter than <em>N-1</em>. <br />
<a class="anchor" id="Perform_Next-Event_Estimation_anchor"></a> <blockquote class="doxtable">
<p><em> <a href="#Perform_Next-Event_Estimation_anchor">&lt;&lt; Perform Next-Event Estimation &gt;&gt;</a> := </em></p>
<p></p>
</blockquote>
<div class="fragment"><div class="line"> <span class="comment">// perform next-event estimation to compute direct lighting</span></div><div class="line"> <span class="keywordflow">if</span> (context.in_bounce + 2 &lt;= context.options.max_path_length)</div><div class="line"> {</div><div class="line">     <span class="comment">// fetch the sampling dimensions</span></div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">float</span> z[3] = { samples[0], samples[1], samples[2] }; <span class="comment">// use dimensions 0,1,2</span></div><div class="line"> </div><div class="line">     <a class="code" href="struct_vertex_geometry_id.html">VertexGeometryId</a> light_vertex;</div><div class="line">     <a class="code" href="struct_vertex_geometry.html">VertexGeometry</a>   light_vertex_geom;</div><div class="line">     <span class="keywordtype">float</span>            light_pdf;</div><div class="line">     <a class="code" href="struct_edf.html">Edf</a>              light_edf;</div><div class="line"> </div><div class="line">     <span class="comment">// sample the light source surface</span></div><div class="line">     renderer.mesh_light.<a class="code" href="group___lights_module.html#ga67cc240bcda4b08efd26c8727144bf16">sample</a>(z, &amp;light_vertex.prim_id, &amp;light_vertex.uv, &amp;light_vertex_geom, &amp;light_pdf, &amp;light_edf);</div><div class="line">    </div><div class="line">    <span class="comment">// join the light sample with the current vertex</span></div><div class="line">    <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a> out = (light_vertex_geom.position - ev.geom.position);</div><div class="line">                          </div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> d2 = fmaxf(1.0e-8f, cugar::square_length(out));</div><div class="line">    </div><div class="line">    <span class="comment">// normalize the outgoing direction</span></div><div class="line">    out *= rsqrtf(d2);</div><div class="line">    </div><div class="line">    <span class="comment">// evaluate the light&#39;s EDF, predivided by the sample pdf</span></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a> f_L = light_edf.<a class="code" href="structcugar_1_1_lambert_edf.html#aed2fed71aa6a7ad98e05714a0fd5f316">f</a>(light_vertex_geom, light_vertex_geom.position, -out) / light_pdf;</div><div class="line"></div><div class="line">    <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a> f_s(0.0f);</div><div class="line">    <span class="keywordtype">float</span>           p_s(0.0f);</div><div class="line">    </div><div class="line">    <span class="comment">// evaluate the surface BSDF f() and its sampling pdf p() in one go</span></div><div class="line">    ev.bsdf.<a class="code" href="struct_bsdf.html#af1ad14ad4a31c7604581a551c3fb1901">f_and_p</a>(ev.geom, ev.in, out, f_s, p_s, cugar::kProjectedSolidAngle);</div><div class="line">    </div><div class="line">    <a href="#Compute_the_sample_value_anchor">&lt;&lt; Compute the sample value &gt;&gt;</a></div><div class="line">    <a href="#Enqueue_a_shadow_ray_anchor">&lt;&lt; Enqueue a shadow ray &gt;&gt;</a></div><div class="line">}</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>Computing the sample value would require multiplying together the current path weight, <em>w</em>, the EDF, <em>f_L</em>, the BSDF, <em>f_s</em> and the geometric throughput term, <em>G</em>, and divide everything by the sample pdf. In practice, we have pre-divided <em>f_L</em> by the pdf <em>light_pdf</em>, so we can now avoid this last division. However, as our path sampler will also be able to hit the light sources, we'll use multiple importance sampling (in short, MIS) between NEE and the possibility of hitting the same light on the same point. <br />
<a class="anchor" id="Compute_the_sample_value_anchor"></a> <blockquote class="doxtable">
<p><em> <a href="#Compute_the_sample_value_anchor">&lt;&lt; Compute the sample value &gt;&gt;</a> := </em></p>
<p></p>
</blockquote>
<div class="fragment"><div class="line"><span class="comment">// evaluate the geometric term</span></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">float</span> G = fabsf(cugar::dot(out, ev.geom.normal_s) * cugar::dot(out, light_vertex_geom.normal_s)) / d2;</div><div class="line"></div><div class="line"><span class="comment">// perform MIS with the possibility of directly hitting the light source</span></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">float</span> p1 = light_pdf;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">float</span> p2 = p_s * G;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">float</span> mis_w = context.in_bounce &gt; 0 ? mis_heuristic&lt;MIS_HEURISTIC&gt;(p1, p2) : 1.0f;</div><div class="line"></div><div class="line"><span class="comment">// calculate the cumulative sample weight, equal to f_L * f_s * G / p</span></div><div class="line"><span class="keyword">const</span> <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a> out_w = w.xyz() * f_L * f_s * G * mis_w;</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>Finally, we can enqueue a shadow ray, carrying the pixel index and sample weight together with the ray itself. <br />
<a class="anchor" id="Enqueue_a_shadow_ray_anchor"></a> <blockquote class="doxtable">
<p><em> <a href="#Enqueue_a_shadow_ray_anchor">&lt;&lt; Enqueue a shadow ray &gt;&gt;</a> := </em></p>
<p></p>
</blockquote>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (cugar::max_comp(out_w) &gt; 0.0f &amp;&amp; cugar::is_finite(out_w))</div><div class="line">{</div><div class="line">    <span class="comment">// enqueue the output ray</span></div><div class="line">    <a class="code" href="struct_masked_ray.html">MaskedRay</a> out_ray;</div><div class="line">    out_ray.origin   = ev.geom.position - ray.dir * 1.0e-4f; <span class="comment">// shift back in space along the viewing direction</span></div><div class="line">    out_ray.dir      = (light_vertex_geom.position - out_ray.origin); <span class="comment">//out;</span></div><div class="line">    out_ray.mask     = 0x2u;</div><div class="line">    out_ray.tmax     = 0.9999f; <span class="comment">//d * 0.9999f;</span></div><div class="line">    </div><div class="line">    <span class="comment">// append the ray to the shadow queue</span></div><div class="line">    context.shadow_queue.warp_append( pixel_index, out_ray, <a class="code" href="structcugar_1_1_vector.html">cugar::Vector4f</a>(out_w, 0.0f) );</div><div class="line">}</div></div><!-- fragment --></dd></dl>
<h2><a class="anchor" id="EvaluatingEmissiveHitsSection"></a>
Evaluating Emissive Hits</h2>
<dl class="section user"><dt></dt><dd>Evaluating emissive surface hits allows us to have a second technique to form complete light paths joining the camera to the light sources, which is often far more efficient than NEE when the BSDF is glossy or close to specular. In principle, it is very similar to evaluating NEE, except that sampling a point on the light source has to be replaced by evaluating the pdf of generating it, which again we'll need to perform MIS. Also, in this case we will not need to enqueue any additional rays (since we have already landed on a light source), and can just add the weighted sample contribution to the framebuffer. Notice that we will further weight the sample by <em>frame_weight = 1 / (instance + 1)</em>, in order to average together this pass with all the previous ones. <br />
<a class="anchor" id="Evaluate_emissive_hits_anchor"></a> <blockquote class="doxtable">
<p><em> <a href="#Evaluate_emissive_hits_anchor">&lt;&lt; Evaluate emissive hits &gt;&gt;</a> := </em></p>
<p></p>
</blockquote>
<div class="fragment"><div class="line">        <span class="comment">// accumulate the emissive component along the incoming direction</span></div><div class="line">        {</div><div class="line">            <a class="code" href="struct_vertex_geometry.html">VertexGeometry</a>  light_vertex_geom = ev.geom; <span class="comment">// the light source geometry IS the current vertex geometry</span></div><div class="line">            <span class="keywordtype">float</span>           light_pdf;</div><div class="line">            <a class="code" href="struct_edf.html">Edf</a>             light_edf;</div><div class="line"></div><div class="line">            <span class="comment">// calculate the pdf of sampling this point on the light source</span></div><div class="line">            renderer.mesh_light.<a class="code" href="group___lights_module.html#gaf14a70f7d23b422f8953bc55d1eade44">map</a>(hit.triId, <a class="code" href="structcugar_1_1_vector.html">cugar::Vector2f</a>(hit.u, hit.v), light_vertex_geom, &amp;light_pdf, &amp;light_edf );</div><div class="line"></div><div class="line">            <span class="comment">// evaluate the edf&#39;s output along the incoming direction</span></div><div class="line">            <span class="keyword">const</span> <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a> f_L = light_edf.<a class="code" href="structcugar_1_1_lambert_edf.html#aed2fed71aa6a7ad98e05714a0fd5f316">f</a>(light_vertex_geom, light_vertex_geom.position, ev.in);</div><div class="line"></div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">float</span> d2 = fmaxf(1.0e-10f, hit.t * hit.t);</div><div class="line"></div><div class="line">            <span class="comment">// compute the MIS weight with next event estimation at the previous vertex</span></div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">float</span> G_partial = fabsf(cugar::dot(ev.in, light_vertex_geom.normal_s)) / d2;</div><div class="line">                <span class="comment">// NOTE: G_partial doesn&#39;t include the dot product between &#39;in and the normal at the previous vertex</span></div><div class="line"></div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">float</span> p1 = G_partial * p_prev; <span class="comment">// NOTE: p_prev = p_proj * dot(in,normal)</span></div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">float</span> p2 = light_pdf;</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">float</span> mis_w = context.in_bounce &gt; 0 ? mis_heuristic&lt;MIS_HEURISTIC&gt;(p1, p2) : 1.0f;</div><div class="line"></div><div class="line">            <span class="comment">// and accumulate the weighted contribution</span></div><div class="line">            <span class="keyword">const</span> <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a> out_w = w.xyz() * f_L * mis_w;</div><div class="line"></div><div class="line">            <span class="comment">// and accumulate the weighted contribution</span></div><div class="line">            <span class="keywordflow">if</span> (cugar::max_comp(out_w) &gt; 0.0f &amp;&amp; cugar::is_finite(out_w))</div><div class="line">            {</div><div class="line">                <span class="comment">// accumulate the sample contribution to the image</span></div><div class="line">                add_in&lt;false&gt;(renderer.fb(FBufferDesc::COMPOSITED_C), pixel_index, out_w, context.frame_weight);</div><div class="line">            }</div><div class="line">        }</div></div><!-- fragment --> </dd></dl>
<h2><a class="anchor" id="EvaluatingScatteringAbsorptionSection"></a>
Evaluating Scattering and Absorption</h2>
<dl class="section user"><dt></dt><dd>The last bit of <a class="el" href="_hello_renderer_page.html#shade_vertex_anchor">shade_vertex()</a> involves sampling a scattering or an absorption event. For this, we will use the last 3 of the random numbers we chose, and rely on the <a class="el" href="group___b_p_t_lib_core.html#ga161551b8c343e47e329703e71e0aaeca">scatter()</a> utility function. This function will sample the BSDF, and return both the BSDF value, predivided by the projected sampling pdf, as well as the pdf itself and a <a class="el" href="struct_bsdf.html#a5f7db6f81220ed9ee6da109d6eb5b585">Bsdf::ComponentType</a> flag telling us which component has been sampled. If the flag is equal to Bsdf::kAbsorption, the path should be terminated. <br />
<a class="anchor" id="Evaluate_scattering_and_absorption_anchor"></a> <blockquote class="doxtable">
<p><em> <a href="#Evaluate_scattering_and_absorption_anchor">&lt;&lt; Evaluate scattering and absorption &gt;&gt;</a> := </em></p>
<p></p>
</blockquote>
<div class="fragment"><div class="line">        <span class="comment">// compute a scattering event / trace a bounce ray</span></div><div class="line">        <span class="keywordflow">if</span> (context.in_bounce + 1 &lt; context.options.max_path_length)</div><div class="line">        {</div><div class="line">            <span class="comment">// fetch the sampling dimensions</span></div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">float</span> z[3] = { samples[3], samples[4], samples[5] }; <span class="comment">// use dimensions 3,4,5</span></div><div class="line"></div><div class="line">            <span class="comment">// sample a scattering event</span></div><div class="line">            <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a>     out(0.0f);</div><div class="line">            <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a>     g(0.0f);</div><div class="line">            <span class="keywordtype">float</span>               p(0.0f);</div><div class="line">            <span class="keywordtype">float</span>               p_proj(0.0f);</div><div class="line">            <a class="code" href="struct_bsdf.html#a5f7db6f81220ed9ee6da109d6eb5b585">Bsdf::ComponentType</a> out_comp(Bsdf::kAbsorption);</div><div class="line"></div><div class="line">            <span class="comment">// compute a scattering direction</span></div><div class="line">            <a class="code" href="group___b_p_t_lib_core.html#ga161551b8c343e47e329703e71e0aaeca">scatter</a>(ev, z, out_comp, out, p, p_proj, g, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, Bsdf::kAllComponents);</div><div class="line"></div><div class="line">            <span class="comment">// compute the output weight</span></div><div class="line">            <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a> out_w = g * w.xyz();</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (p != 0.0f &amp;&amp; cugar::max_comp(out_w) &gt; 0.0f &amp;&amp; cugar::is_finite(out_w))</div><div class="line">            {</div><div class="line">                <span class="comment">// enqueue the output ray</span></div><div class="line">                <a class="code" href="struct_masked_ray.html">MaskedRay</a> out_ray;</div><div class="line">                out_ray.origin  = ev.geom.position;</div><div class="line">                out_ray.dir     = out;</div><div class="line">                out_ray.mask    = __float_as_uint(1.0e-3f);</div><div class="line">                out_ray.tmax    = 1.0e8f;</div><div class="line"></div><div class="line">                <span class="comment">// track the solid angle probability of this scattering event</span></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">float</span> out_p = p;</div><div class="line"></div><div class="line">                <span class="comment">// append the ray to the scattering queue</span></div><div class="line">                <span class="comment">//</span></div><div class="line">                <span class="comment">// notice that we pack the sample probability together with the sample value in a single</span></div><div class="line">                <span class="comment">// float4, so as to allow a single 16-byte write into the output queue.</span></div><div class="line">                context.scatter_queue.warp_append( pixel_index, out_ray, <a class="code" href="structcugar_1_1_vector.html">cugar::Vector4f</a>( out_w, out_p ) );</div><div class="line">                <span class="keywordflow">return</span> <span class="keyword">true</span>;    <span class="comment">// continue the path</span></div><div class="line">            }</div><div class="line">        }</div></div><!-- fragment --> </dd></dl>
<h2><a class="anchor" id="HelloPTPackagingAllTogetherSection"></a>
Packaging it All Together</h2>
<dl class="section user"><dt></dt><dd>Now that our <a class="el" href="_hello_renderer_page.html#shade_vertex_anchor">shade_vertex()</a> function is complete, it remains to package it into a kernel which fetches tasks (i.e. vertices to be shaded) from the input queue, and executes them. Again, this is nothing complex: we'll spawn one thread per queue entry, and have each thread fetch one queue item and pass it to <a class="el" href="_hello_renderer_page.html#shade_vertex_anchor">shade_vertex()</a>. <a class="anchor" id="shade_vertices_anchor"></a> <br />
 <div class="fragment"><div class="line"><span class="comment">// shade vertices kernel</span></div><div class="line"><span class="comment">//</span></div><div class="line">__global__</div><div class="line"><span class="keywordtype">void</span> shade_vertices_kernel(<span class="keyword">const</span> uint32 in_queue_size, HelloPTContext context, <a class="code" href="struct_rendering_context_view.html">RenderingContextView</a> renderer)</div><div class="line">{</div><div class="line">    <span class="keyword">const</span> uint32 thread_id = threadIdx.x + blockIdx.x * blockDim.x;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (thread_id &lt; in_queue_size) <span class="comment">// *context.in_queue.size</span></div><div class="line">    {</div><div class="line">        <span class="keyword">const</span> uint32          pixel_index       = context.in_queue.pixels[thread_id].x;</div><div class="line">        <span class="keyword">const</span> <a class="code" href="struct_masked_ray.html">MaskedRay</a>       ray               = context.in_queue.rays[thread_id];</div><div class="line">        <span class="keyword">const</span> <a class="code" href="struct_hit.html">Hit</a>             hit               = context.in_queue.hits[thread_id];</div><div class="line">        <span class="keyword">const</span> <a class="code" href="structcugar_1_1_vector.html">cugar::Vector4f</a> w                 = context.in_queue.weights[thread_id];</div><div class="line"></div><div class="line">        <span class="keyword">const</span> uint2 pixel = make_uint2(</div><div class="line">            pixel_index % renderer.res_x,</div><div class="line">            pixel_index / renderer.res_x</div><div class="line">        );</div><div class="line"></div><div class="line">        <a class="code" href="group___p_t_lib_core.html#ga9b8be237ade285e6db792a9ea7bf900e">shade_vertex</a>(</div><div class="line">            context,</div><div class="line">            renderer,</div><div class="line">            pixel_index,</div><div class="line">            pixel,</div><div class="line">            ray,</div><div class="line">            hit,</div><div class="line">            w.xyz(),</div><div class="line">            w.w );</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// dispatch the shade hits kernel</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keywordtype">void</span> shade_vertices(<span class="keyword">const</span> uint32 in_queue_size, HelloPTContext context, <a class="code" href="struct_rendering_context_view.html">RenderingContextView</a> renderer)</div><div class="line">{</div><div class="line">    <span class="keyword">const</span> uint32 blockSize(64);</div><div class="line">    <span class="keyword">const</span> dim3 gridSize(<a class="code" href="group___basic_utils.html#gabb6714186dbbd864f0a9298944ba509b">cugar::divide_ri</a>(in_queue_size, blockSize));</div><div class="line"></div><div class="line">    shade_vertices_kernel&lt;&lt;&lt; gridSize, blockSize &gt;&gt;&gt;( in_queue_size, context, renderer );</div><div class="line">}</div></div><!-- fragment --> </dd></dl>
<h1><a class="anchor" id="HelloPTSolvingOcclusionSection"></a>
Resolving Occlusion</h1>
<dl class="section user"><dt></dt><dd>The next and last bit of our pipeline is a kernel that takes tasks from the shadow queue, representing next-event samples, and resolves their occlusion using the corresponding ray hits. If the samples are not occluded, they will be accumulated to their originating pixel. <a class="anchor" id="resolve_occlusion_anchor"></a> <br />
 <div class="fragment"><div class="line"><span class="comment">// a kernel to resolve NEE samples&#39; occlusion</span></div><div class="line"><span class="comment">//</span></div><div class="line">__global__</div><div class="line"><span class="keywordtype">void</span> resolve_occlusion_kernel(</div><div class="line">    <span class="keyword">const</span> uint32            shadow_queue_size,</div><div class="line">    HelloPTContext          context,</div><div class="line">    <a class="code" href="struct_rendering_context_view.html">RenderingContextView</a>    renderer)</div><div class="line">{</div><div class="line">    <span class="keyword">const</span> uint32 thread_id = threadIdx.x + blockIdx.x * blockDim.x;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (thread_id &lt; shadow_queue_size) <span class="comment">// *context.shadow_queue.size</span></div><div class="line">    {</div><div class="line">        <span class="keyword">const</span> uint32          pixel_index   = context.shadow_queue.pixels[thread_id].x;</div><div class="line">        <span class="keyword">const</span> <a class="code" href="struct_hit.html">Hit</a>             hit           = context.shadow_queue.hits[thread_id];</div><div class="line">        <span class="keyword">const</span> <a class="code" href="structcugar_1_1_vector.html">cugar::Vector4f</a> w             = context.shadow_queue.weights[thread_id];</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (hit.t &lt; 0.0f) <span class="comment">// add this sample if and only if there was no intersection</span></div><div class="line">            add_in&lt;false&gt;( renderer.fb(FBufferDesc::COMPOSITED_C), pixel_index, w.xyz(), context.frame_weight );</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// dispatch the resolve_occlusion kernel</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keywordtype">void</span> resolve_occlusion(</div><div class="line">    <span class="keyword">const</span> uint32            shadow_queue_size,</div><div class="line">    HelloPTContext          context,</div><div class="line">    <a class="code" href="struct_rendering_context_view.html">RenderingContextView</a>    renderer)</div><div class="line">{</div><div class="line">    <span class="keyword">const</span> uint32 blockSize(64);</div><div class="line">    <span class="keyword">const</span> dim3 gridSize(<a class="code" href="group___basic_utils.html#gabb6714186dbbd864f0a9298944ba509b">cugar::divide_ri</a>(shadow_queue_size, blockSize));</div><div class="line"></div><div class="line">    resolve_occlusion_kernel&lt;&lt;&lt; gridSize, blockSize &gt;&gt;&gt;( shadow_queue_size, context, renderer );</div><div class="line">}</div></div><!-- fragment --> </dd></dl>
<h1><a class="anchor" id="HelloPTPluginSection"></a>
The Plugin</h1>
<dl class="section user"><dt></dt><dd>In order to get the new renderer picked up by the Fermat executable (fermat.exe), we need to write a plugin <a class="el" href="struct_d_l_l.html">DLL</a> that can be loaded at runtime. As anticipated, this <a class="el" href="struct_d_l_l.html">DLL</a> needs to export a single function, in this case registering the new <a class="el" href="struct_hello_p_t.html">HelloPT</a> factory: <br />
<blockquote class="doxtable">
<p><em> hellopt_plugin.cpp </em></p>
<p></p>
</blockquote>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;hellopt.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;renderer.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// define the plugin entry point</span></div><div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> uint32 __declspec(dllexport) __stdcall register_plugin(<a class="code" href="struct_rendering_context.html">RenderingContext</a>&amp; renderer)</div><div class="line">{</div><div class="line">    <span class="comment">// register the new renderer factory and return the assigned id</span></div><div class="line">    <span class="keywordflow">return</span> renderer.<a class="code" href="struct_rendering_context.html#a69b3e0b8c8cc4aaf4a9751529f86ca68">register_renderer</a>(<span class="stringliteral">&quot;hellopt&quot;</span>, &amp;HelloPT::factory);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> </dd></dl>
<h1><a class="anchor" id="HelloPTDoneSection"></a>
We're Done!</h1>
<dl class="section user"><dt></dt><dd>Pat yourself on the shoulder, we have just finished writing our first sample path tracer in Fermat! <br />
 I am sure you'll have some unanswered questions in your head, though hopefully they are not way too many... </dd></dl>
<dl class="section user"><dt></dt><dd>In fact, if you have already compiled the entire Fermat solution, and you have the dll placed in the same directory as Fermat's executable, you should be able to run the <a class="el" href="struct_hello_p_t.html">HelloPT</a> plugin renderer interactively by just launching: <br />
<pre class="fragment">*  fermat.exe -view -plugin hellopt.dll -path-length 6 -i ../../models/bathroom2/bathroom.obj -c ../../models/bathroom2/camera2.txt -o output/hellopt.tga
* </pre> </dd></dl>
<dl class="section user"><dt></dt><dd>and if all goes well, waiting long enough you should get an image like this:</dd></dl>
<div class="image">
<img src="bathroom.png" style="position:relative; bottom:-10px; border:0px; width:760px;"/>
</div>
<p><br />
 </p><dl class="section user"><dt></dt><dd>Despite the fact that a lot of details were hidden behind some helper functions and classes (e.g. for sampling and evaluating BSDFs, or mesh emitters), this example is still rather low level. In the following pages we'll see that Fermat provides much higher level constructs and libraries to implement both forward and bidirectional path tracers, based on the realization that the underlying structure of these path samplers is more or less always the same, and that one typically only needs to <em>customize</em> their behaviour at specific points (e.g. specifying how exactly NEE is performed, or performing a custom action, like checking a cache, any time a new vertex is generated, or again specifying how the samples are weighted and finally consumed). We will also see that Fermat typically splits these libraries into two distinct components: a <em>core</em> library of singled-threaded device or host/device functions (i.e. functions meant to be called by and operate within an individual thread, that are still completely thread-safe - so there could be millions such threads working in parallel), and a higher level library of <em>parallel kernels</em> and host dispatch functions, typically providing a generalized skeleton of the queue-based pipeline mechanism we just described here.</dd></dl>
<p>Next: <a class="el" href="_p_t_lib_page.html">PTLib</a> </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
