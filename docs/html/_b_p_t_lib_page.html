<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>Fermat: BPTLib</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">
    (function(i, s, o, g, r, a, m) {
        i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function() {
            (i[r].q = i[r].q || []).push(arguments)
        }, i[r].l = 1 * new Date(); a = s.createElement(o),
  m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
    })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');
    ga('create', 'UA-47310325-1', 'nvlabs.github.io');
    ga('send', 'pageview');
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Fermat
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">BPTLib </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Top: <a class="el" href="_overture_contents_page.html">Contents</a></p>
<p><a class="el" href="group___b_p_t_lib.html">BPTLib</a> is a flexible bidirectional path tracing library, thought to be as performant as possible and yet vastly configurable at compile-time. The module is organized into a host library of parallel kernels, <a class="el" href="group___b_p_t_lib.html">BPTLib</a>, and a core module of device-side functions, <a class="el" href="group___b_p_t_lib_core.html">BPTLibCore</a>. The underlying idea is that all the bidirectional sampling functions and kernels are designed to use a wavefront scheduling approach, in which ray tracing queries are queued from shading kernels, and get processed in separate waves.</p>
<h1><a class="anchor" id="BPTLibCoreSection"></a>
BPTLibCore Description</h1>
<dl class="section user"><dt></dt><dd><a class="el" href="group___b_p_t_lib_core.html">BPTLibCore</a> provides functions to:<ul>
<li>generate primary light vertices, i.e. vertices on the light source surfaces, each accompanied by a sampled outgoing direction</li>
<li>process secondary light vertices, starting from ray hits corresponding to the sampled outgoing direction at the previous vertex</li>
<li>generate primary eye vertices, i.e. vertices on the camera, each accompanied by a sampled outgoing direction</li>
<li>process secondary eye vertices, starting from ray hits corresponding to the sampled outgoing direction at the previous vertex </li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd>In order to make the whole process configurable, all the functions accept the following template interfaces: </dd></dl>
<dl class="section user"><dt></dt><dd><a class="anchor" id="TBPTContext"></a><ol type="1">
<li>a context interface, holding members describing the current path tracer state, including all the necessary queues, a set of options, and the storage for recording all generated light vertices; this class needs to inherit from <a class="el" href="struct_b_p_t_context_base.html">BPTContextBase</a> : <br />
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TBPTOptions&gt;</div><div class="line"><span class="keyword">struct </span><a class="code" href="struct_b_p_t_context_base.html">BPTContextBase</a></div><div class="line">{</div><div class="line">    <a class="code" href="struct_b_p_t_context_base.html">BPTContextBase</a>() :</div><div class="line">        in_bounce(0) {}</div><div class="line"></div><div class="line">    <a class="code" href="struct_b_p_t_context_base.html">BPTContextBase</a>(</div><div class="line">        <span class="keyword">const</span> <a class="code" href="struct_rendering_context_view.html">RenderingContextView</a>&amp; _renderer,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="struct_vertex_storage_view.html">VertexStorageView</a>&amp;    _light_vertices,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="struct_b_p_t_queues_view.html">BPTQueuesView</a>&amp;        _queues,</div><div class="line">        <span class="keyword">const</span> TBPTOptions           _options = TBPTOptions()) :</div><div class="line">        in_bounce(0),</div><div class="line">        light_vertices(_light_vertices),</div><div class="line">        in_queue(_queues.in_queue),</div><div class="line">        shadow_queue(_queues.shadow_queue),</div><div class="line">        scatter_queue(_queues.scatter_queue),</div><div class="line">        options(_options)</div><div class="line">    {</div><div class="line">        set_camera(_renderer.camera, _renderer.res_x, _renderer.res_y, _renderer.aspect);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// precompute some camera-related quantities</span></div><div class="line">    <span class="keywordtype">void</span> set_camera(<span class="keyword">const</span> <a class="code" href="struct_camera.html">Camera</a>&amp; camera, <span class="keyword">const</span> uint32 res_x, <span class="keyword">const</span> uint32 res_y, <span class="keyword">const</span> <span class="keywordtype">float</span> aspect_ratio)</div><div class="line">    {</div><div class="line">        <a class="code" href="group___camera_module.html#gaac6a57c4883a499e09399d5f617eccaf">camera_frame</a>(camera, aspect_ratio, camera_U, camera_V, camera_W);</div><div class="line"></div><div class="line">        camera_W_len = <a class="code" href="group___basic.html#ga6a0f89325f62dc313d300e36f2a26b55">cugar::length</a>(camera_W);</div><div class="line"></div><div class="line">        <span class="comment">//camera_square_focal_length = camera.square_pixel_focal_length(res_x, res_y);</span></div><div class="line">        camera_square_focal_length = camera.square_screen_focal_length();</div><div class="line">    }</div><div class="line"></div><div class="line">    uint32              in_bounce;</div><div class="line">    <a class="code" href="struct_ray_queue.html">RayQueue</a>            in_queue;</div><div class="line">    <a class="code" href="struct_ray_queue.html">RayQueue</a>            shadow_queue;</div><div class="line">    <a class="code" href="struct_ray_queue.html">RayQueue</a>            scatter_queue;</div><div class="line"></div><div class="line">    <a class="code" href="struct_vertex_storage_view.html">VertexStorageView</a>   light_vertices;</div><div class="line"></div><div class="line">    <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a>     camera_U;</div><div class="line">    <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a>     camera_V;</div><div class="line">    <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a>     camera_W;</div><div class="line">    <span class="keywordtype">float</span>               camera_W_len;</div><div class="line">    <span class="keywordtype">float</span>               camera_square_focal_length;</div><div class="line"></div><div class="line">    TBPTOptions         options;</div><div class="line">};</div></div><!-- fragment --><br />
<a class="anchor" id="TBPTConfig"></a></li>
<li>a user defined "policy" class, configuring the path sampling process; this class is responsible for deciding what exactly to do at and with each eye and light subpath vertex, and needs to provide the following interface: <br />
<div class="fragment"><div class="line"><span class="keyword">struct </span>TBPTConfig</div><div class="line">{</div><div class="line">   uint32  max_path_length         : 10;</div><div class="line">   uint32  light_sampling          : 1;</div><div class="line">   uint32  light_ordering          : 1;</div><div class="line">   uint32  eye_sampling            : 1;</div><div class="line">   uint32  use_vpls                : 1;</div><div class="line">   uint32  use_rr                  : 1;</div><div class="line">   uint32  direct_lighting_nee     : 1;</div><div class="line">   uint32  direct_lighting_bsdf    : 1;</div><div class="line">   uint32  indirect_lighting_nee   : 1;</div><div class="line">   uint32  indirect_lighting_bsdf  : 1;</div><div class="line">   uint32  visible_lights          : 1;</div><div class="line">   <span class="keywordtype">float</span>   <a class="code" href="group___b_p_t_lib.html#ga497e0940986e5f948a9dcf42242d39c7">light_tracing</a>;</div><div class="line"></div><div class="line">   <span class="comment">// decide whether to terminate a given light subpath</span></div><div class="line">   <span class="comment">//</span></div><div class="line">   <span class="comment">// \param path_id           index of the light subpath</span></div><div class="line">   <span class="comment">// \param s             vertex number along the light subpath</span></div><div class="line">   FERMAT_HOST_DEVICE FERMAT_FORCEINLINE</div><div class="line">   <span class="keywordtype">bool</span> terminate_light_subpath(<span class="keyword">const</span> uint32 path_id, <span class="keyword">const</span> uint32 s) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">   <span class="comment">// decide whether to terminate a given eye subpath</span></div><div class="line">   <span class="comment">//</span></div><div class="line">   <span class="comment">// \param path_id           index of the eye subpath</span></div><div class="line">   <span class="comment">// \param s             vertex number along the eye subpath</span></div><div class="line">   FERMAT_HOST_DEVICE FERMAT_FORCEINLINE</div><div class="line">   <span class="keywordtype">bool</span> terminate_eye_subpath(<span class="keyword">const</span> uint32 path_id, <span class="keyword">const</span> uint32 t) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">   <span class="comment">// decide whether to store a given light vertex</span></div><div class="line">   <span class="comment">//</span></div><div class="line">   <span class="comment">// \param path_id           index of the light subpath</span></div><div class="line">   <span class="comment">// \param s             vertex number along the light subpath</span></div><div class="line">   FERMAT_HOST_DEVICE FERMAT_FORCEINLINE</div><div class="line">   <span class="keywordtype">bool</span> store_light_vertex(<span class="keyword">const</span> uint32 path_id, <span class="keyword">const</span> uint32 s, <span class="keyword">const</span> <span class="keywordtype">bool</span> absorbed) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">   <span class="comment">// decide whether to perform a bidirectional connection</span></div><div class="line">   <span class="comment">//</span></div><div class="line">   <span class="comment">// \param eye_path_id       index of the eye subpath</span></div><div class="line">   <span class="comment">// \param t             vertex number along the eye subpath</span></div><div class="line">   <span class="comment">// \param absorbed          true if the eye subpath has been absorbed/terminated here</span></div><div class="line">   FERMAT_HOST_DEVICE FERMAT_FORCEINLINE</div><div class="line">   <span class="keywordtype">bool</span> perform_connection(<span class="keyword">const</span> uint32 eye_path_id, <span class="keyword">const</span> uint32 t, <span class="keyword">const</span> <span class="keywordtype">bool</span> absorbed) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">   <span class="comment">// decide whether to accumulate an emissive sample from a pure (eye) path tracing estimator</span></div><div class="line">   <span class="comment">//</span></div><div class="line">   <span class="comment">// \param eye_path_id       index of the eye subpath</span></div><div class="line">   <span class="comment">// \param t             vertex number along the eye subpath</span></div><div class="line">   <span class="comment">// \param absorbed          true if the eye subpath has been absorbed/terminated here</span></div><div class="line">   FERMAT_HOST_DEVICE FERMAT_FORCEINLINE</div><div class="line">   <span class="keywordtype">bool</span> accumulate_emissive(<span class="keyword">const</span> uint32 eye_path_id, <span class="keyword">const</span> uint32 t, <span class="keyword">const</span> <span class="keywordtype">bool</span> absorbed) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">   <span class="comment">// process/store the given light vertex</span></div><div class="line">   <span class="comment">//</span></div><div class="line">   FERMAT_HOST_DEVICE FERMAT_FORCEINLINE</div><div class="line">   <span class="keywordtype">void</span> visit_light_vertex(</div><div class="line">       <span class="keyword">const</span> uint32            light_path_id,</div><div class="line">       <span class="keyword">const</span> uint32            depth,</div><div class="line">       <span class="keyword">const</span> <a class="code" href="struct_vertex_geometry_id.html">VertexGeometryId</a>  v_id,</div><div class="line">       TBPTContext&amp;            context,</div><div class="line">       <a class="code" href="struct_rendering_context_view.html">RenderingContextView</a>&amp;   renderer) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">   <span class="comment">// process/store the given eye vertex</span></div><div class="line">   <span class="comment">//</span></div><div class="line">   FERMAT_HOST_DEVICE FERMAT_FORCEINLINE</div><div class="line">   <span class="keywordtype">void</span> visit_eye_vertex(</div><div class="line">       <span class="keyword">const</span> uint32            eye_path_id,</div><div class="line">       <span class="keyword">const</span> uint32            depth,</div><div class="line">       <span class="keyword">const</span> <a class="code" href="struct_vertex_geometry_id.html">VertexGeometryId</a>  v_id,</div><div class="line">       <span class="keyword">const</span> <a class="code" href="struct_eye_vertex.html">EyeVertex</a>&amp;        v,</div><div class="line">       TBPTContext&amp;            context,</div><div class="line">       <a class="code" href="struct_rendering_context_view.html">RenderingContextView</a>&amp;   renderer) <span class="keyword">const</span>;</div><div class="line">};</div></div><!-- fragment --> <br />
In practice, an implementation can inherit from the pre-packaged <a class="el" href="struct_b_p_t_config_base.html">BPTConfigBase</a> class and override any of its methods. <br />
<br />
<a class="anchor" id="TSampleSink"></a></li>
<li>a user defined sample "sink" class, specifying what to do with all the generated bidirectional path samples (i.e. full paths); this class needs to expose the same interface as <a class="el" href="struct_sample_sink_base.html">SampleSinkBase</a> : <br />
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="struct_sample_sink_base.html">SampleSinkBase</a></div><div class="line">{</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TBPTContext&gt;</div><div class="line">    FERMAT_HOST_DEVICE</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="struct_sample_sink_base.html#ab34316c125cab0da36ea2ae41e67f98f">sink</a>(</div><div class="line">        <span class="keyword">const</span> uint32            channel,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="structcugar_1_1_vector.html">cugar::Vector4f</a>   value,</div><div class="line">        <span class="keyword">const</span> uint32            light_path_id,</div><div class="line">        <span class="keyword">const</span> uint32            eye_path_id,</div><div class="line">        <span class="keyword">const</span> uint32            s,</div><div class="line">        <span class="keyword">const</span> uint32            t,</div><div class="line">        TBPTContext&amp;            context,</div><div class="line">        <a class="code" href="struct_rendering_context_view.html">RenderingContextView</a>&amp;   renderer)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TBPTContext&gt;</div><div class="line">    FERMAT_HOST_DEVICE</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="struct_sample_sink_base.html#ac96fd485e8196264c43115c68a0bbc25">sink_eye_scattering_event</a>(</div><div class="line">        <span class="keyword">const</span> <a class="code" href="struct_bsdf.html#a5f7db6f81220ed9ee6da109d6eb5b585">Bsdf::ComponentType</a>   component,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="structcugar_1_1_vector.html">cugar::Vector4f</a>       value,</div><div class="line">        <span class="keyword">const</span> uint32                eye_path_id,</div><div class="line">        <span class="keyword">const</span> uint32                t,</div><div class="line">        TBPTContext&amp;                context,</div><div class="line">        <a class="code" href="struct_rendering_context_view.html">RenderingContextView</a>&amp;       renderer)</div><div class="line">    {}</div><div class="line">};</div></div><!-- fragment --><br />
<a class="anchor" id="TPrimaryCoordinates"></a></li>
<li>a user defined class specifying the primary sample space coordinates of the generated subpaths; this class needs to expose the following itnerface: <br />
<div class="fragment"><div class="line"><span class="keyword">struct </span>TPrimaryCoords</div><div class="line">{</div><div class="line">   <span class="comment">// return the primary sample space coordinate of the d-th component of the j-th vertex</span></div><div class="line">   <span class="comment">// of the i-th subpath</span></div><div class="line">   <span class="comment">//</span></div><div class="line">   <span class="comment">// \param idx       the subpath index &#39;i&#39;</span></div><div class="line">   <span class="comment">// \param vertex    the vertex index &#39;j&#39; in the given subpath</span></div><div class="line">   <span class="comment">// \param dim       the index of the dimension &#39;d&#39; of the given subpath vertex</span></div><div class="line">   FERMAT_HOST_DEVICE FERMAT_FORCEINLINE</div><div class="line">   <span class="keywordtype">float</span> sample(<span class="keyword">const</span> uint32 idx, <span class="keyword">const</span> uint32 vertex, <span class="keyword">const</span> uint32 dim) <span class="keyword">const</span>;</div><div class="line">};</div></div><!-- fragment --> </li>
</ol>
</dd></dl>
<dl class="section user"><dt></dt><dd>The complete list of functions can be found in the <a class="el" href="group___b_p_t_lib_core.html">BPTLibCore</a> module documentation.</dd></dl>
<h1><a class="anchor" id="BPTLibSection"></a>
BPTLib Description</h1>
<dl class="section user"><dt></dt><dd><a class="el" href="group___b_p_t_lib.html">BPTLib</a> contains the definition of the full bidirectional path tracing pipeline; as for the lower level <a class="el" href="group___b_p_t_lib_core.html">BPTLibCore</a> functions, the pipeline is customizable through a <a class="el" href="_b_p_t_lib_page.html#TBPTConfig">TBPTConfig</a> policy class, a <a class="el" href="_b_p_t_lib_page.html#TSampleSink">TSampleSink</a>, and a set of <a class="el" href="_b_p_t_lib_page.html#TPrimaryCoordinates">TPrimaryCoordinates</a>. </dd></dl>
<dl class="section user"><dt></dt><dd>While the module itself defines all separate stages of the pipeline, the entire pipeline can be instanced with a single host function call to:</dd></dl>
<p><a class="anchor" id="sample_paths_anchor"></a></p><div class="fragment"><div class="line"><span class="comment">// A host function dispatching a series of kernels to sample a given number of full paths.</span></div><div class="line"><span class="comment">// The generated paths are controlled by two user-defined sets of primary space coordinates, one</span></div><div class="line"><span class="comment">// for eye and light subpaths sampling.</span></div><div class="line"><span class="comment">// Specifically, this function executes the following two functions:</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// - \ref sample_light_subpaths()</span></div><div class="line"><span class="comment">// - \ref sample_eye_subpaths()</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// \tparam TEyePrimaryCoordinates       a set of primary space coordinates, see TPrimaryCoordinates</span></div><div class="line"><span class="comment">// \tparam TLightPrimaryCoordinates     a set of primary space coordinates, see TPrimaryCoordinates</span></div><div class="line"><span class="comment">// \tparam TSampleSink                  a sample sink, specifying what to do with each generated path sample</span></div><div class="line"><span class="comment">// \tparam TBPTContext                  a bidirectional path tracing context clas</span></div><div class="line"><span class="comment">// \tparam TBPTConfig                   a policy class controlling the behaviour of the path sampling process</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// \param n_eye_paths               the number of eye subpaths to sample</span></div><div class="line"><span class="comment">// \param n_light_paths             the number of light subpaths to sample</span></div><div class="line"><span class="comment">// \param eye_primary_coords        the set of primary sample space coordinates used to generate eye subpaths</span></div><div class="line"><span class="comment">// \param light_primary_coords      the set of primary sample space coordinates used to generate light subpaths</span></div><div class="line"><span class="comment">// \param sample_sink               the sample sink</span></div><div class="line"><span class="comment">// \param context                   the bidirectional path tracing context</span></div><div class="line"><span class="comment">// \param config                    the config policy</span></div><div class="line"><span class="comment">// \param renderer                  the host-side rendering context</span></div><div class="line"><span class="comment">// \param renderer_view             a view of the rendering context</span></div><div class="line"><span class="comment">// \param lazy_shadows              a flag indicating whether to resolve shadows lazily, after generating</span></div><div class="line"><span class="comment">//                                  all light and eye vertices, or right away as each wave of new vertices is processed</span></div><div class="line"><span class="keyword">template</span> &lt;</div><div class="line">  <span class="keyword">typename</span> TEyePrimaryCoordinates,</div><div class="line">  <span class="keyword">typename</span> TLightPrimaryCoordinates,</div><div class="line">  <span class="keyword">typename</span> TSampleSink,</div><div class="line">  <span class="keyword">typename</span> TBPTContext,</div><div class="line">  <span class="keyword">typename</span> TBPTConfig&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="group___b_p_t_lib.html#ga4c1164d859ed146eb306e8b7b178c7e7">sample_paths</a>(</div><div class="line">   <span class="keyword">const</span> uint32                n_eye_paths,</div><div class="line">   <span class="keyword">const</span> uint32                n_light_paths,</div><div class="line">   TEyePrimaryCoordinates      eye_primary_coords,</div><div class="line">   TLightPrimaryCoordinates    light_primary_coords,</div><div class="line">   TSampleSink                 sample_sink,</div><div class="line">   TBPTContext&amp;                context,</div><div class="line">   <span class="keyword">const</span> TBPTConfig&amp;           config,</div><div class="line">   <a class="code" href="struct_rendering_context.html">RenderingContext</a>&amp;           renderer,</div><div class="line">   <a class="code" href="struct_rendering_context_view.html">RenderingContextView</a>&amp;       renderer_view,</div><div class="line">   <span class="keyword">const</span> <span class="keywordtype">bool</span>                  lazy_shadows = <span class="keyword">false</span>)</div></div><!-- fragment --><dl class="section user"><dt></dt><dd><a class="el" href="group___b_p_t_lib.html#ga4c1164d859ed146eb306e8b7b178c7e7">sample_paths()</a> generates bidirectional paths with at least two eye vertices, i.e. t=2 in Veach's terminology. A separate function allows to process paths with t=1, connecting directly to a vertex on the lens:</dd></dl>
<p><a class="anchor" id="light_tracing_anchor"></a></p><div class="fragment"><div class="line"><span class="comment">// A host function dispatching a series of kernels to process pure light tracing paths.</span></div><div class="line"><span class="comment">// Specifically, this function executes the following two functions:</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// - \ref light_tracing()</span></div><div class="line"><span class="comment">// - \ref solve_shadows()</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// This function needs to be called &lt;i&gt;after&lt;/i&gt; a previous call to \ref generate_light_subpaths(), as it assumes</span></div><div class="line"><span class="comment">// a set of light subpaths have already been sampled and it is possible to connect them to the camera.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// \tparam TSampleSink                 a sample sink, specifying what to do with each generated path sample, see \ref SampleSinkAnchor</span></div><div class="line"><span class="comment">// \tparam TBPTContext                 a bidirectional path tracing context class, see \ref BPTContextBase</span></div><div class="line"><span class="comment">// \tparam TBPTConfig                  a policy class controlling the behaviour of the path sampling process, see \ref BPTConfigBase</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">template</span> &lt;</div><div class="line">  <span class="keyword">typename</span> TSampleSink,</div><div class="line">  <span class="keyword">typename</span> TBPTContext,</div><div class="line">  <span class="keyword">typename</span> TBPTConfig&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="group___b_p_t_lib.html#ga497e0940986e5f948a9dcf42242d39c7">light_tracing</a>(</div><div class="line">   <span class="keyword">const</span> uint32            n_light_paths,</div><div class="line">   TSampleSink             sample_sink,</div><div class="line">   TBPTContext&amp;            context,</div><div class="line">   <span class="keyword">const</span> TBPTConfig&amp;       config,</div><div class="line">   <a class="code" href="struct_rendering_context.html">RenderingContext</a>&amp;       renderer,</div><div class="line">   <a class="code" href="struct_rendering_context_view.html">RenderingContextView</a>&amp;   renderer_view)</div></div><!-- fragment --><h1><a class="anchor" id="BPTExampleSection"></a>
An Example</h1>
<dl class="section user"><dt></dt><dd>At this point, it might be useful to take a look at the implementation of the <a class="el" href="struct_b_p_t.html">BPT</a> renderer to see how this is used. We'll start from the implementation of the render method:</dd></dl>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="struct_b_p_t.html#af9e940aca306f186cadfabc095590d88">BPT::render</a>(<span class="keyword">const</span> uint32 instance, <a class="code" href="struct_rendering_context.html">RenderingContext</a>&amp; renderer)</div><div class="line">{</div><div class="line">    <span class="comment">// pre-multiply the previous frame for blending</span></div><div class="line">    renderer.<a class="code" href="struct_rendering_context.html#a332a91e18bd96ae06973cc897c34ff07">multiply_frame</a>(<span class="keywordtype">float</span>(instance) / <span class="keywordtype">float</span>(instance + 1));</div><div class="line"></div><div class="line">    <a class="code" href="structcugar_1_1_timer.html">cugar::Timer</a> timer;</div><div class="line">    timer.<a class="code" href="structcugar_1_1_timer.html#a337264814110dc99fd8b78b1267589d7">start</a>();</div><div class="line"></div><div class="line">    <span class="comment">// get a view of the renderer</span></div><div class="line">    <a class="code" href="struct_rendering_context_view.html">RenderingContextView</a> renderer_view = renderer.<a class="code" href="struct_rendering_context.html#a591062fd1887b069a015ede456dcaa93">view</a>(instance);</div><div class="line">    </div><div class="line">    <span class="comment">// initialize the sampling sequence for this frame</span></div><div class="line">    m_sequence.set_instance(instance);</div><div class="line">    </div><div class="line">    <span class="comment">// setup our BPT context</span></div><div class="line">    <a class="code" href="struct_b_p_t_context.html">BPTContext</a> context(*<span class="keyword">this</span>,renderer_view);</div><div class="line"></div><div class="line">    <span class="comment">// setup our BPT configuration</span></div><div class="line">    BPTConfig config(context);</div><div class="line">    </div><div class="line">    <span class="comment">// sample a set of bidirectional paths corresponding to our current primary coordinates</span></div><div class="line">    <a class="code" href="struct_tiled_light_subpath_primary_coords.html">TiledLightSubpathPrimaryCoords</a> light_primary_coords(context.sequence);</div><div class="line"></div><div class="line">    <a class="code" href="struct_per_pixel_eye_subpath_primary_coords.html">PerPixelEyeSubpathPrimaryCoords</a> eye_primary_coords(context.sequence, renderer.<a class="code" href="struct_rendering_context.html#ad1a58510bdaf6f373080835abf5db2db">res</a>().x, renderer.<a class="code" href="struct_rendering_context.html#ad1a58510bdaf6f373080835abf5db2db">res</a>().y);</div><div class="line"></div><div class="line">    ConnectionsSink&lt;false&gt; sink;</div><div class="line">    </div><div class="line">    <span class="comment">// debug only: regenerate the VPLs</span></div><div class="line">    <span class="comment">//regenerate_primary_light_vertices(instance, renderer);</span></div><div class="line"></div><div class="line">    <a class="code" href="group___b_p_t_lib.html#ga4c1164d859ed146eb306e8b7b178c7e7">bpt::sample_paths</a>(</div><div class="line">        m_n_eye_subpaths,</div><div class="line">        m_n_light_subpaths,</div><div class="line">        eye_primary_coords,</div><div class="line">        light_primary_coords,</div><div class="line">        sink,</div><div class="line">        context,</div><div class="line">        config,</div><div class="line">        renderer,</div><div class="line">        renderer_view);</div><div class="line"></div><div class="line">    <span class="comment">// solve pure light tracing occlusions</span></div><div class="line">    {</div><div class="line">        ConnectionsSink&lt;true&gt; atomic_sink;</div><div class="line"></div><div class="line">        <a class="code" href="group___b_p_t_lib.html#ga497e0940986e5f948a9dcf42242d39c7">bpt::light_tracing</a>(</div><div class="line">            m_n_light_subpaths,</div><div class="line">            atomic_sink,</div><div class="line">            context,</div><div class="line">            config,</div><div class="line">            renderer,</div><div class="line">            renderer_view);</div><div class="line">    }</div><div class="line"></div><div class="line">    timer.<a class="code" href="structcugar_1_1_timer.html#a5422f0db9e2758449a30ba41a4480f6d">stop</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> time = timer.seconds();</div><div class="line"></div><div class="line">    <span class="comment">// clear the global timer at instance zero</span></div><div class="line">    m_time = (instance == 0) ? time : time + m_time;</div><div class="line"></div><div class="line">    fprintf(stderr, <span class="stringliteral">&quot;\r  %.1fs (%.1fms)        &quot;</span>,</div><div class="line">        m_time,</div><div class="line">        time * 1000.0f);</div><div class="line">}</div></div><!-- fragment --> <dl class="section user"><dt></dt><dd>Besides some boilerplate, this function instantiates a context, a config, some light and eye primary sample coordinate generators (<a class="el" href="struct_tiled_light_subpath_primary_coords.html">TiledLightSubpathPrimaryCoords</a> and <a class="el" href="struct_per_pixel_eye_subpath_primary_coords.html">PerPixelEyeSubpathPrimaryCoords</a>), and executes the <a class="el" href="group___b_p_t_lib.html#ga4c1164d859ed146eb306e8b7b178c7e7">sample_paths()</a> and <a class="el" href="group___b_p_t_lib.html#ga497e0940986e5f948a9dcf42242d39c7">light_tracing()</a> functions above. What is interesting now is taking a look at the definition of the sample sink class:</dd></dl>
<div class="fragment"><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">bool</span> USE_ATOMICS&gt;</div><div class="line">    <span class="keyword">struct </span>ConnectionsSink : <a class="code" href="struct_sample_sink_base.html">SampleSinkBase</a></div><div class="line">    {</div><div class="line">        FERMAT_HOST_DEVICE</div><div class="line">        ConnectionsSink() {}</div><div class="line"></div><div class="line">        <span class="comment">// accumulate a bidirectional sample</span></div><div class="line">        <span class="comment">//</span></div><div class="line">        FERMAT_HOST_DEVICE</div><div class="line">        <span class="keywordtype">void</span> <a class="code" href="struct_sample_sink_base.html#ab34316c125cab0da36ea2ae41e67f98f">sink</a>(</div><div class="line">            <span class="keyword">const</span> uint32            channel,</div><div class="line">            <span class="keyword">const</span> <a class="code" href="structcugar_1_1_vector.html">cugar::Vector4f</a>   value,</div><div class="line">            <span class="keyword">const</span> uint32            light_path_id,</div><div class="line">            <span class="keyword">const</span> uint32            eye_path_id,</div><div class="line">            <span class="keyword">const</span> uint32            s,</div><div class="line">            <span class="keyword">const</span> uint32            t,</div><div class="line">            <a class="code" href="struct_b_p_t_context.html">BPTContext</a>&amp;             context,</div><div class="line">            <a class="code" href="struct_rendering_context_view.html">RenderingContextView</a>&amp;   renderer)</div><div class="line">        {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">float</span> frame_weight = 1.0f / float(renderer.instance + 1);</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (USE_ATOMICS)</div><div class="line">            {</div><div class="line">                <a class="code" href="group___atomics.html#ga0c9d949be7ac5b6f27a232c7cd27a05c">cugar::atomic_add</a>(&amp;renderer.fb(FBufferDesc::COMPOSITED_C, eye_path_id).x, value.x * frame_weight);</div><div class="line">                <a class="code" href="group___atomics.html#ga0c9d949be7ac5b6f27a232c7cd27a05c">cugar::atomic_add</a>(&amp;renderer.fb(FBufferDesc::COMPOSITED_C, eye_path_id).y, value.y * frame_weight);</div><div class="line">                <a class="code" href="group___atomics.html#ga0c9d949be7ac5b6f27a232c7cd27a05c">cugar::atomic_add</a>(&amp;renderer.fb(FBufferDesc::COMPOSITED_C, eye_path_id).z, value.z * frame_weight);</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> (channel != FBufferDesc::COMPOSITED_C)</div><div class="line">                {</div><div class="line">                    <a class="code" href="group___atomics.html#ga0c9d949be7ac5b6f27a232c7cd27a05c">cugar::atomic_add</a>(&amp;renderer.fb(channel, eye_path_id).x, value.x * frame_weight);</div><div class="line">                    <a class="code" href="group___atomics.html#ga0c9d949be7ac5b6f27a232c7cd27a05c">cugar::atomic_add</a>(&amp;renderer.fb(channel, eye_path_id).y, value.y * frame_weight);</div><div class="line">                    <a class="code" href="group___atomics.html#ga0c9d949be7ac5b6f27a232c7cd27a05c">cugar::atomic_add</a>(&amp;renderer.fb(channel, eye_path_id).z, value.z * frame_weight);</div><div class="line">                }</div><div class="line">            }</div><div class="line">            <span class="keywordflow">else</span></div><div class="line">            {</div><div class="line">                renderer.fb(FBufferDesc::COMPOSITED_C, eye_path_id) += value * frame_weight;</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> (channel != FBufferDesc::COMPOSITED_C)</div><div class="line">                    renderer.fb(channel, eye_path_id) += value * frame_weight;</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// record an eye scattering event</span></div><div class="line">        <span class="comment">//</span></div><div class="line">        FERMAT_HOST_DEVICE</div><div class="line">        <span class="keywordtype">void</span> <a class="code" href="struct_sample_sink_base.html#ac96fd485e8196264c43115c68a0bbc25">sink_eye_scattering_event</a>(</div><div class="line">            <span class="keyword">const</span> <a class="code" href="struct_bsdf.html#a5f7db6f81220ed9ee6da109d6eb5b585">Bsdf::ComponentType</a>   component,</div><div class="line">            <span class="keyword">const</span> <a class="code" href="structcugar_1_1_vector.html">cugar::Vector4f</a>       value,</div><div class="line">            <span class="keyword">const</span> uint32                eye_path_id,</div><div class="line">            <span class="keyword">const</span> uint32                t,</div><div class="line">            <a class="code" href="struct_b_p_t_context.html">BPTContext</a>&amp;                 context,</div><div class="line">            <a class="code" href="struct_rendering_context_view.html">RenderingContextView</a>&amp;       renderer)</div><div class="line">        {</div><div class="line">            <span class="keywordflow">if</span> (t == 2) <span class="comment">// accumulate the albedo of visible surfaces</span></div><div class="line">            {</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">float</span> frame_weight = 1.0f / float(renderer.instance + 1);</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> (component == Bsdf::kDiffuseReflection)</div><div class="line">                    renderer.fb(FBufferDesc::DIFFUSE_A, eye_path_id) += value * frame_weight;</div><div class="line">                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (component == Bsdf::kGlossyReflection)</div><div class="line">                    renderer.fb(FBufferDesc::SPECULAR_A, eye_path_id) += value * frame_weight;</div><div class="line">            }</div><div class="line">        }</div><div class="line">    };</div></div><!-- fragment --> <dl class="section user"><dt></dt><dd>As you may notice, this implementation is simply taking each sample, and accumulating its contribution to the corresponding pixel in the target framebuffer. Here, we are using the fact that the eye path index corresponds exactly to the pixel index, a consequence of using the <a class="el" href="struct_per_pixel_eye_subpath_primary_coords.html">PerPixelEyeSubpathPrimaryCoords</a> class.</dd></dl>
<div class="image">
<img src="water_caustic.jpg" style="position:relative; bottom:-10px; border:0px; width:698px;"/>
</div>
 </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
