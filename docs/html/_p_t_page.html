<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>Fermat: The Path Tracer (Revisited)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">
    (function(i, s, o, g, r, a, m) {
        i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function() {
            (i[r].q = i[r].q || []).push(arguments)
        }, i[r].l = 1 * new Date(); a = s.createElement(o),
  m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
    })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');
    ga('create', 'UA-47310325-1', 'nvlabs.github.io');
    ga('send', 'pageview');
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Fermat
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The <a class="el" href="struct_path.html">Path</a> Tracer (Revisited) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Top: <a class="el" href="_overture_contents_page.html">Contents</a></p>
<div class="image">
<img src="morning-bath-rec.jpg" style="position:relative; bottom:-10px; border:0px; width:740px;"/>
</div>
<p> <br />
</p><dl class="section user"><dt></dt><dd>This chapter aims to show how to use <a class="el" href="group___p_t_lib.html">PTLib</a> library to build a much more streamlined, yet even more powerful path tracer. </dd></dl>
<dl class="section user"><dt></dt><dd>If you take look at the full implementation in <a class="el" href="_p_t_page_code.html">pathtracer_impl.h</a>, you should notice that the overall structure is pretty similar to that of our <a class="el" href="_hello_renderer_page.html">Hello World</a> prototype path-tracer, yet even more compact. We will skip some details and go directly to the important bits. Remember that the central feature of <a class="el" href="group___p_t_lib.html">PTLib</a> is the <a class="el" href="_p_t_lib_page.html#path_trace_loop_anchor">path_trace_loop()</a> function, and that this is configured by a few template classes that need to be provided by the user. The first here is the implementation of the <a class="el" href="_p_t_lib_page.html#TPTContext">TPTContext</a> class: <br />
<div class="fragment"><div class="line">    <span class="comment">// the internal path tracing context</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TDirectLightingSampler&gt;</div><div class="line">    <span class="keyword">struct </span>PathTracingContext : <a class="code" href="struct_p_t_context_base.html">PTContextBase</a>&lt;PTOptions&gt;, <a class="code" href="struct_p_t_context_queues.html">PTContextQueues</a></div><div class="line">    {</div><div class="line">        TDirectLightingSampler dl;</div><div class="line">    };</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>The main news here is the fact we inherited it from <a class="el" href="struct_p_t_context_base.html">PTContextBase</a> and <a class="el" href="struct_p_t_context_queues.html">PTContextQueues</a>, and added a single member, the templated <a class="el" href="_p_t_lib_page.html#TPTDirectLightingSampler">TPTDirectLightingSampler</a>, PathTracingContext::dl.</dd></dl>
<dl class="section user"><dt></dt><dd>The render method itself starts almost identically to the one we already saw:</dd></dl>
<div class="fragment"><div class="line">    <span class="comment">// pre-multiply the previous frame for blending</span></div><div class="line">    renderer.<a class="code" href="struct_rendering_context.html#a6fb940a3b78a8a3faf82676c95ab1e6f">rescale_frame</a>( instance );</div><div class="line"></div><div class="line">    <span class="comment">//fprintf(stderr, &quot;render started (%u)\n&quot;, instance);</span></div><div class="line">    <span class="keyword">const</span> uint2 res = renderer.<a class="code" href="struct_rendering_context.html#ad1a58510bdaf6f373080835abf5db2db">res</a>();</div><div class="line">    <span class="keyword">const</span> uint32 n_pixels = res.x * res.y;</div><div class="line"></div><div class="line">    <a class="code" href="structcugar_1_1memory__arena.html">cugar::memory_arena</a> arena( m_memory_pool.ptr() );</div><div class="line"></div><div class="line">    <a class="code" href="struct_p_t_ray_queue.html">PTRayQueue</a> in_queue;</div><div class="line">    <a class="code" href="struct_p_t_ray_queue.html">PTRayQueue</a> scatter_queue;</div><div class="line">    <a class="code" href="struct_p_t_ray_queue.html">PTRayQueue</a> shadow_queue;</div><div class="line"></div><div class="line">    <a class="code" href="group___p_t_lib.html#gaf8daef8b815f7712ff692edbaa628881">alloc_queues</a>(</div><div class="line">        m_options,</div><div class="line">        n_pixels,</div><div class="line">        in_queue,</div><div class="line">        scatter_queue,</div><div class="line">        shadow_queue,</div><div class="line">        arena );</div><div class="line"></div><div class="line">    <span class="comment">// fetch a view of the renderer</span></div><div class="line">    <a class="code" href="struct_rendering_context_view.html">RenderingContextView</a> renderer_view = renderer.<a class="code" href="struct_rendering_context.html#a591062fd1887b069a015ede456dcaa93">view</a>(instance);</div><div class="line"></div><div class="line">    <span class="comment">// instantiate the vertex processor</span></div><div class="line">    <a class="code" href="struct_p_s_f_p_t_vertex_processor.html">PSFPTVertexProcessor</a> vertex_processor( m_options.firefly_filter );</div></div><!-- fragment --> <dl class="section user"><dt></dt><dd>The main news should be the last two lines:</dd></dl>
<div class="fragment"><div class="line">    <span class="comment">// instantiate the vertex processor</span></div><div class="line">    <a class="code" href="struct_p_s_f_p_t_vertex_processor.html">PSFPTVertexProcessor</a> vertex_processor( m_options.firefly_filter );</div></div><!-- fragment --> <dl class="section user"><dt></dt><dd>i.e. the instantiation of a custom <a class="el" href="_p_t_lib_page.html#TPTVertexProcessor">TPTVertexProcessor</a> - the second template interface that must be implemented in order to configure <a class="el" href="group___p_t_lib.html">PTLib</a>. After that, the body of the render method is almost trivial:</dd></dl>
<div class="fragment"><div class="line">        <span class="comment">// use the Reinforcement-Learning direct-lighting sampler</span></div><div class="line">        <span class="keywordflow">if</span> (m_options.nee_type == NEE_ALGORITHM_RL)</div><div class="line">        {</div><div class="line">            <span class="comment">// initialize the path-tracing context</span></div><div class="line">            PathTracingContext&lt;DirectLightingRL&gt; context;</div><div class="line">            context.options         = m_options;</div><div class="line">            context.in_bounce       = 0;</div><div class="line">            context.in_queue        = in_queue;</div><div class="line">            context.scatter_queue   = scatter_queue;</div><div class="line">            context.shadow_queue    = shadow_queue;</div><div class="line">            context.sequence        = m_sequence.view();</div><div class="line">            context.frame_weight    = 1.0f / float(renderer_view.instance + 1);</div><div class="line">            context.device_timers   = device_timers;</div><div class="line">            context.bbox            = m_bbox;</div><div class="line">            context.dl              = <a class="code" href="struct_direct_lighting_r_l.html">DirectLightingRL</a>(</div><div class="line">                view( *m_vtls_rl ),</div><div class="line">                m_mesh_vtls-&gt;view() );</div><div class="line"></div><div class="line">            <span class="comment">// instantiate the actual path tracing loop</span></div><div class="line">            <a class="code" href="group___p_t_lib.html#gadbd6e824e2ecdd07fae235bddebcd1d8">path_trace_loop</a>( context, vertex_processor, renderer, renderer_view, stats );</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span> <span class="comment">// use the regular mesh emitter direct-lighting sampler</span></div><div class="line">        {</div><div class="line">            <span class="comment">// select which instantiation of the mesh light to use (VPLs or the plain mesh)</span></div><div class="line">            <a class="code" href="struct_mesh_light.html">MeshLight</a> mesh_light = m_options.nee_type == NEE_ALGORITHM_VPL ? renderer_view.mesh_vpls : renderer_view.mesh_light;</div><div class="line"></div><div class="line">            <span class="comment">// initialize the path-tracing context</span></div><div class="line">            PathTracingContext&lt;DirectLightingMesh&gt; context;</div><div class="line">            context.options         = m_options;</div><div class="line">            context.in_bounce       = 0;</div><div class="line">            context.in_queue        = in_queue;</div><div class="line">            context.scatter_queue   = scatter_queue;</div><div class="line">            context.shadow_queue    = shadow_queue;</div><div class="line">            context.sequence        = m_sequence.view();</div><div class="line">            context.frame_weight    = 1.0f / float(renderer_view.instance + 1);</div><div class="line">            context.device_timers   = device_timers;</div><div class="line">            context.bbox            = m_bbox;</div><div class="line">            context.dl              = <a class="code" href="struct_direct_lighting_mesh.html">DirectLightingMesh</a>( mesh_light );</div><div class="line"></div><div class="line">            <span class="comment">// instantiate the actual path tracing loop</span></div><div class="line">            <a class="code" href="group___p_t_lib.html#gadbd6e824e2ecdd07fae235bddebcd1d8">path_trace_loop</a>( context, vertex_processor, renderer, renderer_view, stats );</div><div class="line">        }</div></div><!-- fragment --> <dl class="section user"><dt></dt><dd>You'll notice that there are two parts to it, with two different instantiations of the <a class="el" href="_p_t_lib_page.html#path_trace_loop_anchor">path_trace_loop()</a> call: they correspond to using two different direct-lighting samplers provided by Fermat, the default mesh-based sampler (<a class="el" href="struct_direct_lighting_mesh.html">DirectLightingMesh</a>, second branch), which can be configured to either generate samples on the mesh triangles on the fly, or use a set of pre-sampled VPLs, and a more advanced <a href="https://en.wikipedia.org/wiki/Reinforcement_learning">Reinforcement Learning</a> based sampler (<a class="el" href="struct_direct_lighting_r_l.html">DirectLightingRL</a>, first branch). Other than that, the two branches are almost identical: they initialize the context with all its members, and call into <a class="el" href="_p_t_lib_page.html#path_trace_loop_anchor">path_trace_loop()</a>.</dd></dl>
<dl class="section user"><dt></dt><dd>So what does our vertex processor do, exactly? It implements a few methods specifying how to weight and accumulate the path samples generated by <a class="el" href="_p_t_lib_page.html#path_trace_loop_anchor">path_trace_loop()</a>. The first such method handles the calculation of Next-Event Estimation (NEE) weights:</dd></dl>
<div class="fragment"><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> PTContext&gt;</div><div class="line">    FERMAT_DEVICE</div><div class="line">    <span class="keywordtype">void</span> compute_nee_weights(</div><div class="line">        <span class="keyword">const</span> PTContext&amp;            context,                <span class="comment">// the current context</span></div><div class="line">        <span class="keyword">const</span> <a class="code" href="struct_rendering_context_view.html">RenderingContextView</a>&amp; renderer,               <span class="comment">// the current renderer</span></div><div class="line">        <span class="keyword">const</span> <a class="code" href="union_pixel_info.html">PixelInfo</a>             pixel_info,             <span class="comment">// packed pixel info</span></div><div class="line">        <span class="keyword">const</span> uint32                prev_vertex_info,       <span class="comment">// packed previous vertex info</span></div><div class="line">        <span class="keyword">const</span> uint32                vertex_info,            <span class="comment">// packed vertex info</span></div><div class="line">        <span class="keyword">const</span> <a class="code" href="struct_eye_vertex.html">EyeVertex</a>&amp;            ev,                     <span class="comment">// the local vertex</span></div><div class="line">        <span class="keyword">const</span> <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a>&amp;      f_d,                    <span class="comment">// the diffuse BSDF weight</span></div><div class="line">        <span class="keyword">const</span> <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a>&amp;      f_g,                    <span class="comment">// the glossy BSDF weight</span></div><div class="line">        <span class="keyword">const</span> <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a>&amp;      w,                      <span class="comment">// the current path weight</span></div><div class="line">        <span class="keyword">const</span> <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a>&amp;      f_L,                    <span class="comment">// the current light EDF sample contribution</span></div><div class="line">              <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a>&amp;      out_w_d,                <span class="comment">// the output diffuse weight</span></div><div class="line">              <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a>&amp;      out_w_g,                <span class="comment">// the output glossy weight</span></div><div class="line">              uint32&amp;               out_vertex_info)        <span class="comment">// the output packed vertex info</span></div><div class="line">    {</div><div class="line">        out_w_d = (context.in_bounce == 0 ? f_d : f_d + f_g) * w * f_L;</div><div class="line">        out_w_g = (context.in_bounce == 0 ? f_g : f_d + f_g) * w * f_L;</div><div class="line">        out_vertex_info = 0xFFFFFFFF; <span class="comment">// mark this unused</span></div><div class="line"><span class="comment"></span>    }</div></div><!-- fragment --> <dl class="section user"><dt></dt><dd>The relevant lines are just these:</dd></dl>
<div class="fragment"><div class="line">        out_w_d = (context.in_bounce == 0 ? f_d : f_d + f_g) * w * f_L;</div><div class="line">        out_w_g = (context.in_bounce == 0 ? f_g : f_d + f_g) * w * f_L;</div><div class="line">        out_vertex_info = 0xFFFFFFFF; <span class="comment">// mark this unused</span></div></div><!-- fragment --> <dl class="section user"><dt></dt><dd>For now we'll focus on the first two, and ignore the third and last line; we'll come back to that later. The first says that output diffuse weight, <em>out_w_d</em> should be equal to the local diffuse BSDF component <em>f_d</em>, times the light's EDF <em>f_L</em>, times the path weight <em>w</em> if this is the very first vertex along a path (i.e. the one directly visible from the camera), and otherwise it should be the sum of both the diffuse and glossy components <em>(f_d + f_g)</em>, times the EDF and the path weight. The rationale for this distinction is that this path tracer supports splitting the output to distinct framebuffer channels for diffuse and specular components, and this output diffuse weight is what will be eventually accumulated into the <em>diffuse</em> channel, and we want it to contain the diffuse direct lighting at the first bounce, plus <em>all</em> the indirect lighting (whether glossy or diffuse) seen through any <em>previous diffuse scattering event</em>. The output glossy weight <em>out_w_g</em> is computed with similar logic.</dd></dl>
<dl class="section user"><dt></dt><dd>At this point you might wonder how we're going to find out whether this sample did go through some previous scattering event, and we will find the answer examining the next method, specifying the recipe for the actual sample accumulation:</dd></dl>
<div class="fragment"><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> PTContext&gt;</div><div class="line">    FERMAT_DEVICE</div><div class="line">    <span class="keywordtype">void</span> accumulate_nee(</div><div class="line">        <span class="keyword">const</span> PTContext&amp;            context,                <span class="comment">// the current context</span></div><div class="line">              <a class="code" href="struct_rendering_context_view.html">RenderingContextView</a>&amp; renderer,               <span class="comment">// the current renderer</span></div><div class="line">        <span class="keyword">const</span> <a class="code" href="union_pixel_info.html">PixelInfo</a>             pixel_info,             <span class="comment">// packed pixel info</span></div><div class="line">        <span class="keyword">const</span> uint32                vertex_info,            <span class="comment">// packed vertex info</span></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">bool</span>                  shadow_hit,             <span class="comment">// the hit information</span></div><div class="line">        <span class="keyword">const</span> <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a>&amp;      w_d,                    <span class="comment">// the diffuse NEE weight</span></div><div class="line">        <span class="keyword">const</span> <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a>&amp;      w_g)                    <span class="comment">// the glossy NEE weight</span></div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> (shadow_hit == <span class="keyword">false</span>)</div><div class="line">        {</div><div class="line">            <a class="code" href="struct_f_buffer_view.html">FBufferView</a>&amp; fb = renderer.fb;</div><div class="line">            <a class="code" href="struct_f_buffer_channel_view.html">FBufferChannelView</a>&amp; composited_channel = fb(FBufferDesc::COMPOSITED_C);</div><div class="line">            <a class="code" href="struct_f_buffer_channel_view.html">FBufferChannelView</a>&amp; diffuse_channel    = fb(FBufferDesc::DIFFUSE_C);</div><div class="line">            <a class="code" href="struct_f_buffer_channel_view.html">FBufferChannelView</a>&amp; specular_channel   = fb(FBufferDesc::SPECULAR_C);</div><div class="line"></div><div class="line">            <span class="keyword">const</span> uint32 pixel_index = pixel_info.pixel;</div><div class="line">            <span class="keyword">const</span> uint32 pixel_comp  = pixel_info.comp;</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">float</span> frame_weight = context.frame_weight;</div><div class="line"></div><div class="line">            add_in&lt;false&gt;( composited_channel, pixel_index, w_d + w_g, frame_weight );</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (context.in_bounce == 0)</div><div class="line">            {</div><div class="line">                <span class="comment">// accumulate the per-component values to the respective output channels</span></div><div class="line">                add_in&lt;true&gt;( diffuse_channel,  pixel_index, w_d, frame_weight );</div><div class="line">                add_in&lt;true&gt;( specular_channel, pixel_index, w_g, frame_weight );</div><div class="line">            }</div><div class="line">            <span class="keywordflow">else</span></div><div class="line">            {</div><div class="line">                <span class="comment">// accumulate the per-component value to the proper output channel</span></div><div class="line">                <span class="keywordflow">if</span> (pixel_comp &amp; Bsdf::kDiffuseMask) add_in&lt;true&gt;( diffuse_channel,  pixel_index, w_d, frame_weight );</div><div class="line">                <span class="keywordflow">if</span> (pixel_comp &amp; Bsdf::kGlossyMask)  add_in&lt;true&gt;( specular_channel, pixel_index, w_g, frame_weight );</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --> <dl class="section user"><dt></dt><dd>Here you can notice that, again, we have some special casing for the first bounce - which adds both the diffuse and the glossy sample values to their respective channels - and another case for all other bounces - which selectively write to <em>either</em> the diffuse <em>or</em> the glossy channel based on the <em>pixel_info.comp</em> field, which is exactly what <a class="el" href="group___p_t_lib.html">PTLib</a> uses to mark whether a path is diffuse or glossy (or in other words, whether the first scattering event as seen from the camera was diffuse or glossy).</dd></dl>
<dl class="section user"><dt></dt><dd>The next method we should look at is the one specifying the assignment of the new path weight after a scattering event:</dd></dl>
<div class="fragment"><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> PTContext&gt;</div><div class="line">    FERMAT_DEVICE</div><div class="line">    <span class="keywordtype">void</span> compute_scattering_weights(</div><div class="line">        <span class="keyword">const</span> PTContext&amp;            context,                <span class="comment">// the current context</span></div><div class="line">        <span class="keyword">const</span> <a class="code" href="struct_rendering_context_view.html">RenderingContextView</a>&amp; renderer,               <span class="comment">// the current renderer</span></div><div class="line">        <span class="keyword">const</span> <a class="code" href="union_pixel_info.html">PixelInfo</a>             pixel_info,             <span class="comment">// packed pixel info</span></div><div class="line">        <span class="keyword">const</span> uint32                prev_vertex_info,       <span class="comment">// packed previous vertex info</span></div><div class="line">        <span class="keyword">const</span> uint32                vertex_info,            <span class="comment">// packed vertex info</span></div><div class="line">        <span class="keyword">const</span> <a class="code" href="struct_eye_vertex.html">EyeVertex</a>&amp;            ev,                     <span class="comment">// the local vertex</span></div><div class="line">        <span class="keyword">const</span> uint32                out_comp,               <span class="comment">// the bsdf scattering component</span></div><div class="line">        <span class="keyword">const</span> <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a>&amp;      g,                      <span class="comment">// the bsdf scattering weight (= f/p)</span></div><div class="line">        <span class="keyword">const</span> <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a>&amp;      w,                      <span class="comment">// the current path weight</span></div><div class="line">              <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a>&amp;      out_w,                  <span class="comment">// the output path weight</span></div><div class="line">              uint32&amp;               out_vertex_info)        <span class="comment">// the output vertex info</span></div><div class="line">    {</div><div class="line">        out_w = g * w;</div><div class="line">        out_vertex_info = 0xFFFFFFFF; <span class="comment">// mark this unused</span></div><div class="line">    }</div></div><!-- fragment --> <dl class="section user"><dt></dt><dd>and again, besides the function signature boilerplate, this method is very simple: it says that the output path weight <em>out_w</em> should be the product of the local BSDF scattering weight <em>g</em> (which is calculated as the BSDF value divided by the sampling pdf, i.e. <em>g = f/p</em>), times the current path weight <em>w</em>.</dd></dl>
<dl class="section user"><dt></dt><dd>Finally, we'll look at the recipe for accumulating emissive vertices found along a path:</dd></dl>
<div class="fragment"><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> PTContext&gt;</div><div class="line">    FERMAT_DEVICE</div><div class="line">    <span class="keywordtype">void</span> accumulate_emissive(</div><div class="line">        <span class="keyword">const</span> PTContext&amp;            context,                <span class="comment">// the current context</span></div><div class="line">              <a class="code" href="struct_rendering_context_view.html">RenderingContextView</a>&amp; renderer,               <span class="comment">// the current renderer</span></div><div class="line">        <span class="keyword">const</span> <a class="code" href="union_pixel_info.html">PixelInfo</a>             pixel_info,             <span class="comment">// packed pixel info</span></div><div class="line">        <span class="keyword">const</span> uint32                prev_vertex_info,       <span class="comment">// packed previous vertex info</span></div><div class="line">        <span class="keyword">const</span> uint32                vertex_info,            <span class="comment">// packed vertex info</span></div><div class="line">        <span class="keyword">const</span> <a class="code" href="struct_eye_vertex.html">EyeVertex</a>&amp;            ev,                     <span class="comment">// the local vertex</span></div><div class="line">        <span class="keyword">const</span> <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a>&amp;      w)                      <span class="comment">// the current path weight</span></div><div class="line">    {</div><div class="line">        <a class="code" href="struct_f_buffer_view.html">FBufferView</a>&amp; fb = renderer.fb;</div><div class="line">        <a class="code" href="struct_f_buffer_channel_view.html">FBufferChannelView</a>&amp; composited_channel = fb(FBufferDesc::COMPOSITED_C);</div><div class="line">        <a class="code" href="struct_f_buffer_channel_view.html">FBufferChannelView</a>&amp; direct_channel     = fb(FBufferDesc::DIRECT_C);</div><div class="line">        <a class="code" href="struct_f_buffer_channel_view.html">FBufferChannelView</a>&amp; diffuse_channel    = fb(FBufferDesc::DIFFUSE_C);</div><div class="line">        <a class="code" href="struct_f_buffer_channel_view.html">FBufferChannelView</a>&amp; specular_channel   = fb(FBufferDesc::SPECULAR_C);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> uint32 pixel_index = pixel_info.pixel;</div><div class="line">        <span class="keyword">const</span> uint32 pixel_comp  = pixel_info.comp;</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> frame_weight = context.frame_weight;</div><div class="line"></div><div class="line">        <span class="comment">// accumulate to the image</span></div><div class="line">        add_in&lt;false&gt;(composited_channel, pixel_index, w, frame_weight);</div><div class="line"></div><div class="line">        <span class="comment">// accumulate the per-component value to the proper output channel</span></div><div class="line">        <span class="keywordflow">if</span> (context.in_bounce == 0)</div><div class="line">            add_in&lt;false&gt;(direct_channel, pixel_index, w, frame_weight);</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">            <span class="keywordflow">if</span> (pixel_comp &amp; Bsdf::kDiffuseMask) add_in&lt;true&gt;(diffuse_channel,  pixel_index, w, frame_weight);</div><div class="line">            <span class="keywordflow">if</span> (pixel_comp &amp; Bsdf::kGlossyMask)  add_in&lt;true&gt;(specular_channel, pixel_index, w, frame_weight);</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --> <dl class="section user"><dt></dt><dd>and hopefully at this point you sort of understand what's going on: the emissive sample <em>w</em> is simply accumulated to the various framebuffer channels it contributes to, again depending on whether this is the first bounce (in which case the sample represents direct lighting), or a secondary one.</dd></dl>
<dl class="section user"><dt></dt><dd>This should more or less clarify how to use <a class="el" href="group___p_t_lib.html">PTLib</a>. More importantly, it should clarify what it is designed for: implementing massively parallel, <em>customizable</em> path tracers, without actually writing any of the relatively complex kernel and queueing logic necessary to implement them. In the next chapter, we'll see a more advanced use case, where the same exact library is customized to perform path space filtering. Incidentally, so far we didn't quite explain what were all those <em>packed vertex_info</em>'s that we blatantly initialized to 0xFFFFFFFF (essentially marking them <em>unused</em>): the next section will show what they can be used for.</dd></dl>
<p>Next: <a class="el" href="_p_s_f_p_t_page.html">The Path-Space Filtering Path Tracer</a> </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
