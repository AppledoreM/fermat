<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>Fermat: The Path-Space Filtering Path Tracer</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">
    (function(i, s, o, g, r, a, m) {
        i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function() {
            (i[r].q = i[r].q || []).push(arguments)
        }, i[r].l = 1 * new Date(); a = s.createElement(o),
  m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
    })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');
    ga('create', 'UA-47310325-1', 'nvlabs.github.io');
    ga('send', 'pageview');
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Fermat
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The Path-Space Filtering <a class="el" href="struct_path.html">Path</a> Tracer </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Top: <a class="el" href="_overture_contents_page.html">Contents</a></p>
<dl class="section user"><dt></dt><dd>In order to highlight the flexibility of our <a class="el" href="group___p_t_lib.html">PTLib</a> library, we will now describe an implementation of the <a href="https://dl.acm.org/citation.cfm?id=3214806">Fast path space filtering by jittered spatial hashing</a> algorithm by Binder et al. built on top of this framework. </dd></dl>
<dl class="section user"><dt></dt><dd>The main idea behind this algorithm is that rather than utilizing the sampled paths directly and splatting them to their single originating pixel only, they are cut somewhere in the middle (the original paper was doing this at the first bounce, we extend this to an arbitrary vertex), and the contributions at the specified vertex are merged and averaged (or "filtered") into a discrete spatial hash. This way, the filtered value averaged into a single cell will be virtually "splat" to all paths incident to that cell, and consequently to all the corresponding pixels (dramatically decreasing variance at the expense of some bias, or error). The whole process is illustrated for two paths in the following figure: <div class="image">
<img src="psfpt-scheme.jpg" style="position:relative; bottom:-10px; border:0px; width:500px;"/>
</div>
 </dd></dl>
<dl class="section user"><dt></dt><dd>Now, taking a look at Fermat's implementation in <a class="el" href="_p_s_f_p_t_page_code.html">psfpt_impl.h</a>, you'll notice that the overall structure is pretty similar to that of our <a class="el" href="_hello_renderer_page.html">Hello World</a> prototype path-tracer, and even more to that of the <a class="el" href="_p_t_page.html">PTLib-based Path Tracer</a>. Skipping some details, you'll notice there is again a context class definition: <br />
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TDirectLightingSampler&gt;</div><div class="line"><span class="keyword">struct </span>PSFPTContext : <a class="code" href="struct_p_t_context_base.html">PTContextBase</a>&lt;PSFPTOptions&gt;, <a class="code" href="struct_p_t_context_queues.html">PTContextQueues</a></div><div class="line">{</div><div class="line">   PSFRefQueue ref_queue;      <span class="comment">// a queue of PSF references</span></div><div class="line"></div><div class="line">   HashMap     psf_hashmap;    <span class="comment">// the PSF hashmap</span></div><div class="line">   float4*     psf_values;     <span class="comment">// the PSF values</span></div><div class="line"></div><div class="line">   TDirectLightingSampler dl;  <span class="comment">// the direct-lighting sampler</span></div><div class="line">};</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>The main news here is the fact we inherited it from <a class="el" href="struct_p_t_context_base.html">PTContextBase</a> and <a class="el" href="struct_p_t_context_queues.html">PTContextQueues</a>, and added a few fields: <br />
<ul>
<li>an additional "references queue"</li>
<li>a hashmap and the corresponding values</li>
<li>and a direct lighting sampler. </li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd>The additional queue is needed to store references to the hashmap cells. These references represent forward paths sampled from the camera that land on some cell, with their corresponding path weight (i.e. the throughput the path was carrying until it hit the cell, properly divided by its sampling pdf). We need to keep these references around because we are going to employ a two pass algorithm: a first one in which full paths are sampled and cut at the specified vertex, inserting their outgoing radiance into the corresponding hash cell, and a final one in which all the cell references created in the first pass are looked up and splat on screen. This two-stage separation is needed to make sure that <em>all</em> samples are filtered together <em>before</em> we actually splat them.</dd></dl>
<dl class="section user"><dt></dt><dd>The beginning of the <a class="el" href="struct_p_s_f_p_t.html#aac923cb36f8f1d8ad27f01becef44fd9">PSFPT::render()</a> method should also look fairly familiar:</dd></dl>
<div class="fragment"><div class="line">    <span class="keyword">const</span> uint2 res = renderer.<a class="code" href="struct_rendering_context.html#ad1a58510bdaf6f373080835abf5db2db">res</a>();</div><div class="line">    <span class="keyword">const</span> uint32 n_pixels = res.x * res.y;</div><div class="line">    </div><div class="line">    <span class="comment">// carve an arena out of the pre-allocated memory pool</span></div><div class="line">    <a class="code" href="structcugar_1_1memory__arena.html">cugar::memory_arena</a> arena( m_memory_pool.ptr() );</div><div class="line"></div><div class="line">    <span class="comment">// alloc all the queues</span></div><div class="line">    <a class="code" href="struct_p_t_ray_queue.html">PTRayQueue</a>  input_queue;</div><div class="line">    <a class="code" href="struct_p_t_ray_queue.html">PTRayQueue</a>  scatter_queue;</div><div class="line">    <a class="code" href="struct_p_t_ray_queue.html">PTRayQueue</a>  shadow_queue;</div><div class="line">    PSFRefQueue ref_queue;</div><div class="line"></div><div class="line">    <a class="code" href="group___p_t_lib.html#gaf8daef8b815f7712ff692edbaa628881">alloc_queues</a>(</div><div class="line">        m_options,</div><div class="line">        n_pixels,</div><div class="line">        input_queue,</div><div class="line">        scatter_queue,</div><div class="line">        shadow_queue,</div><div class="line">        ref_queue,</div><div class="line">        arena );</div><div class="line"></div><div class="line">    <span class="comment">// fetch a view of the renderer</span></div><div class="line">    <a class="code" href="struct_rendering_context_view.html">RenderingContextView</a> renderer_view = renderer.<a class="code" href="struct_rendering_context.html#a591062fd1887b069a015ede456dcaa93">view</a>(instance);</div><div class="line"></div><div class="line">    <span class="comment">// instantiate our vertex processor</span></div><div class="line">    <a class="code" href="struct_p_s_f_p_t_vertex_processor.html">PSFPTVertexProcessor</a> vertex_processor( m_options.firefly_filter );</div></div><!-- fragment --> <dl class="section user"><dt></dt><dd>In fact, the only news here should be the very last two lines:</dd></dl>
<div class="fragment"><div class="line">    <span class="comment">// instantiate our vertex processor</span></div><div class="line">    <a class="code" href="struct_p_s_f_p_t_vertex_processor.html">PSFPTVertexProcessor</a> vertex_processor( m_options.firefly_filter );</div></div><!-- fragment --><p> i.e. the instantiation of a custom <a class="el" href="_p_t_lib_page.html#TPTVertexProcessor">TPTVertexProcessor</a> - in this case the <a class="el" href="struct_p_s_f_p_t_vertex_processor.html">PSFPTVertexProcessor</a>. After that, the body of the render method is almost trivial:</p>
<div class="fragment"><div class="line">            PSFPTContext&lt;DirectLightingMesh&gt; context;</div><div class="line">            context.options         = m_options;</div><div class="line">            context.in_bounce       = 0;</div><div class="line">            context.in_queue        = input_queue;</div><div class="line">            context.scatter_queue   = scatter_queue;</div><div class="line">            context.shadow_queue    = shadow_queue;</div><div class="line">            context.sequence        = m_sequence.view();</div><div class="line">            context.frame_weight    = 1.0f / float(renderer_view.instance + 1);</div><div class="line">            context.device_timers   = device_timers;</div><div class="line">            context.bbox            = m_bbox;</div><div class="line">            context.dl              = <a class="code" href="struct_direct_lighting_mesh.html">DirectLightingMesh</a>( mesh_light );</div><div class="line">            context.ref_queue       = ref_queue;</div><div class="line">            context.psf_hashmap     = HashMap(</div><div class="line">                HASH_SIZE,</div><div class="line">                m_psf_hash.m_keys.ptr(),</div><div class="line">                m_psf_hash.m_unique.ptr(),</div><div class="line">                m_psf_hash.m_slots.ptr(),</div><div class="line">                m_psf_hash.m_size.ptr()</div><div class="line">            );</div><div class="line">            context.psf_values = m_psf_values.ptr();</div><div class="line"></div><div class="line">            <span class="comment">// initialize the shading cache</span></div><div class="line">            <span class="keywordflow">if</span> ((instance % m_options.psf_temporal_reuse) == 0)</div><div class="line">                m_psf_hash.clear();</div><div class="line"></div><div class="line">            <span class="comment">// reset the reference queue size</span></div><div class="line">            cudaMemset(context.ref_queue.size, 0x00, <span class="keyword">sizeof</span>(uint32));</div><div class="line">            CUDA_CHECK(cugar::cuda::sync_and_check_error(<span class="stringliteral">&quot;clear reference queue&quot;</span>));</div><div class="line"></div><div class="line">            <span class="comment">// perform the actual path tracing</span></div><div class="line">            <a class="code" href="group___p_t_lib.html#gadbd6e824e2ecdd07fae235bddebcd1d8">path_trace_loop</a>( context, vertex_processor, renderer, renderer_view, stats );</div><div class="line"></div><div class="line">            <span class="comment">// blend-in the PSF references</span></div><div class="line">            <span class="keywordflow">if</span> (pass_type == PSFPT::kFinalPass)</div><div class="line">            {</div><div class="line">                uint32 ref_queue_size;</div><div class="line">                cudaMemcpy(&amp;ref_queue_size, context.ref_queue.size, <span class="keyword">sizeof</span>(uint32), cudaMemcpyDeviceToHost);</div><div class="line"></div><div class="line">                psf_blending(ref_queue_size, context, renderer_view);</div><div class="line">                CUDA_CHECK(cugar::cuda::sync_and_check_error(<span class="stringliteral">&quot;psf blending&quot;</span>));</div><div class="line">            }</div></div><!-- fragment --> <dl class="section user"><dt></dt><dd>All path tracing and kernel dispatch complexity has been absorbed into <a class="el" href="_p_t_lib_page.html">PTLib</a>! Particularly, it has been absorbed in the <a class="el" href="_p_t_lib_page.html#path_trace_loop_anchor">path_trace_loop()</a> method.</dd></dl>
<dl class="section user"><dt></dt><dd>All of it, except for some crucial details. The details specified by our <a class="el" href="struct_p_s_f_p_t_vertex_processor.html">PSFPTVertexProcessor</a> policy class, the class saying what exactly needs to be done with the path vertices generated by <a class="el" href="_p_t_lib_page.html">PTLib</a> itself.</dd></dl>
<dl class="section user"><dt></dt><dd>The first method this class is responsible for implementing is the preprocess_vertex() method, which is called each time a new path vertex is created, before anything is actually done at that very vertex. Here, we use this to perform our jittered spatial hashing of the vertex position and normal coordinates, and retrieve the corresponding hash cell:</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// preprocess a vertex and return some packed vertex info</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TPTContext&gt;</div><div class="line">FERMAT_DEVICE</div><div class="line">uint32 preprocess_vertex(</div><div class="line">         TPTContext&amp;           context,            <span class="comment">// the current context</span></div><div class="line">   <span class="keyword">const</span> <a class="code" href="struct_rendering_context_view.html">RenderingContextView</a>&amp; renderer,           <span class="comment">// the current renderer</span></div><div class="line">   <span class="keyword">const</span> <a class="code" href="union_pixel_info.html">PixelInfo</a>             pixel_info,         <span class="comment">// packed pixel info</span></div><div class="line">   <span class="keyword">const</span> <a class="code" href="struct_eye_vertex.html">EyeVertex</a>&amp;            ev,                 <span class="comment">// the local vertex</span></div><div class="line">   <span class="keyword">const</span> <span class="keywordtype">float</span>                 cone_radius,        <span class="comment">// the current cone radius</span></div><div class="line">   <span class="keyword">const</span> <a class="code" href="structcugar_1_1_bbox.html">cugar::Bbox3f</a>         scene_bbox,         <span class="comment">// the scene bounding box</span></div><div class="line">   <span class="keyword">const</span> uint32                prev_vertex_info,   <span class="comment">// the packed vertex info at the previous vertex</span></div><div class="line">   <span class="keyword">const</span> <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a>       w,                  <span class="comment">// the current path weight</span></div><div class="line">   <span class="keyword">const</span> <span class="keywordtype">float</span>                 p_prev)             <span class="comment">// the scattering solid angle probability at the previous vertex</span></div><div class="line">{</div><div class="line">   <span class="comment">// access the vertex info we returned at the previous vertex along this path (sampled from the eye)</span></div><div class="line">   CacheInfo prev_cache_info(prev_vertex_info);</div><div class="line"></div><div class="line">   <span class="comment">// determine the cache slot</span></div><div class="line">   uint32 new_cache_slot = prev_cache_info.pixel;</div><div class="line">   <span class="keywordtype">bool</span>   new_cache_entry = <span class="keyword">false</span>;</div><div class="line">   </div><div class="line">   <span class="comment">// We should create a new cache entry if and only if:</span></div><div class="line">   <span class="comment">//  1. none has been created so far along this path</span></div><div class="line">   <span class="comment">//  2. the depth is sufficient</span></div><div class="line">   <span class="comment">//  3. other conditions like the hit being at a minimum distance and the sampling probability being low enough (indicating a rough-enough interaction) hold</span></div><div class="line">   <span class="keywordflow">if</span> (prev_cache_info.is_invalid() &amp;&amp;</div><div class="line">       context.in_bounce &gt;= context.options.psf_depth &amp;&amp;</div><div class="line">       p_prev &lt; context.options.psf_max_prob)</div><div class="line">   {</div><div class="line">       <a href="#Compute_per-pixel_jittering_coordinates_anchor">&lt;&lt; Compute per-pixel jittering coordinates &gt;&gt;</a></div><div class="line">       <a href="#Compute_a_spatial_hashkey_anchor">&lt;&lt; Compute a spatial hashkey &gt;&gt;</a></div><div class="line">       <a href="#Insert_key_into_the_hashmap_anchor">&lt;&lt; Insert key into the hashmap &gt;&gt;</a></div><div class="line">       <a href="#Append_references_to_the_PSF_queue_anchor">&lt;&lt; Append references to the PSF queue &gt;&gt;</a></div><div class="line">       <a href="#Finalize_anchor">&lt;&lt; Finalize &gt;&gt;</a></div><div class="line">   }</div><div class="line">   <span class="keywordflow">return</span> CacheInfo(new_cache_slot, 0, new_cache_entry);</div><div class="line">}</div></div><!-- fragment --><dl class="section user"><dt></dt><dd>The first step is computing some random numbers to jitter the spatial hashing itself:</dd></dl>
<p><a class="anchor" id="Compute_per-pixel_jittering_coordinates_anchor"></a></p><blockquote class="doxtable">
<p><em> <a href="#Compute_per-pixel_jittering_coordinates_anchor">&lt;&lt; Compute per-pixel jittering coordinates &gt;&gt;</a> := </em></p>
<p></p>
</blockquote>
<div class="fragment"><div class="line">            <span class="keyword">const</span> uint32 pixel_hash = pixel_info.pixel + renderer.instance * renderer.res_x * renderer.res_y;</div><div class="line"></div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">float</span> jitter[6] = {</div><div class="line">                <a class="code" href="group___basic.html#ga215e28e8a87955931f3cdb9b9797ff68">cugar::randfloat</a>( 0u, pixel_hash ),</div><div class="line">                <a class="code" href="group___basic.html#ga215e28e8a87955931f3cdb9b9797ff68">cugar::randfloat</a>( 1u, pixel_hash ),</div><div class="line">                <a class="code" href="group___basic.html#ga215e28e8a87955931f3cdb9b9797ff68">cugar::randfloat</a>( 2u, pixel_hash ),</div><div class="line">                <a class="code" href="group___basic.html#ga215e28e8a87955931f3cdb9b9797ff68">cugar::randfloat</a>( 3u, pixel_hash ),</div><div class="line">                <a class="code" href="group___basic.html#ga215e28e8a87955931f3cdb9b9797ff68">cugar::randfloat</a>( 4u, pixel_hash ),</div><div class="line">                <a class="code" href="group___basic.html#ga215e28e8a87955931f3cdb9b9797ff68">cugar::randfloat</a>( 5u, pixel_hash ),</div><div class="line">            };</div></div><!-- fragment --> <dl class="section user"><dt></dt><dd>After that, computing the hash key is fairly straightforward:</dd></dl>
<p><a class="anchor" id="Compute_a_spatial_hashkey_anchor"></a></p><blockquote class="doxtable">
<p><em> <a href="#Compute_a_spatial_hash_key_anchor">&lt;&lt; Compute a spatial hash key &gt;&gt;</a> := </em></p>
<p></p>
</blockquote>
<div class="fragment"><div class="line">            <span class="comment">// compute a spatial hash</span></div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">float</span> cone_scale   = context.options.psf_width;</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">float</span> filter_scale = (context.in_bounce == 0.0f ? 2.0f : 1.0f);</div><div class="line"></div><div class="line">            <span class="comment">// compute a hash key based on jittered hashing of the position and normal coordinates</span></div><div class="line">            <span class="keyword">const</span> uint64 shading_key = <a class="code" href="group___spatial_hash_module.html#ga04c40211588f9601e16bc99d3bef70ed">spatial_hash</a>(</div><div class="line">                pixel_info.pixel,</div><div class="line">                ev.geom.position,</div><div class="line">                <a class="code" href="group___vectors_module.html#gab7854923b97b44405c7335f0df540fd3">dot</a>(ev.in, ev.geom.normal_s) &gt; 0.0f ? ev.geom.normal_s : -ev.geom.normal_s,</div><div class="line">                ev.geom.tangent,</div><div class="line">                ev.geom.binormal,</div><div class="line">                context.bbox,</div><div class="line">                jitter,</div><div class="line">                cone_radius * cone_scale,</div><div class="line">                filter_scale);</div></div><!-- fragment --> <dl class="section user"><dt></dt><dd>and so is insertion into the hashmap:</dd></dl>
<p><a class="anchor" id="Insert_key_into_the_hashmap_anchor"></a></p><blockquote class="doxtable">
<p><em> <a href="#Insert_key_into_the_hashmap_anchor">&lt;&lt; Insert key into the hashmap &gt;&gt;</a> := </em></p>
<p></p>
</blockquote>
<div class="fragment"><div class="line">            <span class="comment">// insert into the hashmap using the computed hash key</span></div><div class="line">            <span class="keywordflow">if</span> (context.psf_hashmap.insert(shading_key, <a class="code" href="group___basic.html#ga4c88b92d7c3a2616868a11282da2be2f">cugar::hash</a>(shading_key), &amp;new_cache_slot) == <span class="keyword">true</span>)</div><div class="line">            {</div><div class="line">                FERMAT_ASSERT(new_cache_slot &lt; cugar::cuda::load&lt;cugar::cuda::LOAD_VOLATILE&gt;(context.psf_hashmap.count));</div><div class="line">                <span class="comment">// initialize the cache entry</span></div><div class="line">                context.psf_values[new_cache_slot] = make_float4(0.0f, 0.0f, 0.0f, 0.0f);</div><div class="line">            }</div><div class="line">            FERMAT_ASSERT(new_cache_slot &lt; cugar::cuda::load&lt;cugar::cuda::LOAD_VOLATILE&gt;(context.psf_hashmap.count));</div><div class="line"></div><div class="line">            <span class="comment">// increment the sample counter</span></div><div class="line">            <a class="code" href="group___atomics.html#ga0c9d949be7ac5b6f27a232c7cd27a05c">cugar::atomic_add</a>(&amp;context.psf_values[new_cache_slot].w, 1.0f);</div></div><!-- fragment --> <dl class="section user"><dt></dt><dd>Finally, we need to append a reference to this newly created cell into the PSF splatting queue, and finalize, marking our cell as new:</dd></dl>
<p><a class="anchor" id="Append_references_to_the_PSF_queue_anchor"></a></p><blockquote class="doxtable">
<p><em> <a href="#Append_references_to_the_PSF_queue_anchor">&lt;&lt; Append references to the PSF queue &gt;&gt;</a> := </em></p>
<p></p>
</blockquote>
<div class="fragment"><div class="line">            <span class="comment">// add two &quot;references&quot; to this sample, weighted by modulate( w, ev.bsdf.diffuse )</span></div><div class="line">            <span class="keyword">const</span> <a class="code" href="structcugar_1_1_vector.html">cugar::Vector4f</a> w_mod = modulate(<a class="code" href="structcugar_1_1_vector.html">cugar::Vector4f</a>(w,0.0f), ev.material.diffuse);</div><div class="line"></div><div class="line">            context.ref_queue.warp_append(</div><div class="line">                pixel_info,</div><div class="line">                CacheInfo(new_cache_slot, ALL_COMPS, 0),</div><div class="line">                (pixel_info.comp &amp; Bsdf::kDiffuseMask)                     ? w_mod : <a class="code" href="structcugar_1_1_vector.html">cugar::Vector4f</a>(0.0f),</div><div class="line">                (pixel_info.comp &amp; Bsdf::kGlossyMask) &amp;&amp; context.in_bounce ? w_mod : <a class="code" href="structcugar_1_1_vector.html">cugar::Vector4f</a>(0.0f)</div><div class="line">                    <span class="comment">// at the first bounce, cache entries are only accumulated into the diffuse channel</span></div><div class="line">            );</div></div><!-- fragment --><p> <a class="anchor" id="Finalize_anchor"></a></p><blockquote class="doxtable">
<p><em> <a href="#Finalize_anchor">&lt;&lt; Finalize &gt;&gt;</a> := </em></p>
<p></p>
</blockquote>
<div class="fragment"><div class="line">            new_cache_entry = <span class="keyword">true</span>;</div></div><!-- fragment --> <dl class="section user"><dt></dt><dd>Notice that the method returns an integer, which is later passed to all other methods as <em>vertex_info</em>. Here we use this integer to pack all the information we'll need later on, that is to say: the hash cell index, a bit flag indicating whether this hash cell has been newly created, i.e. this is <b>the first diffuse vertex</b> along the path where filtering is performed, or whether the cell was already looked-up by some previous vertex, and some extra flags indicating the components this path is sampling (e.g. diffuse or glossy). For convenience, we use a simple helper class to wrap this information in an easily accessible bit field:</dd></dl>
<div class="fragment"><div class="line">    <span class="keyword">union </span>CacheInfo</div><div class="line">    {</div><div class="line">        <span class="keyword">const</span> <span class="keyword">static</span> uint32 INVALID = 0xFFFFFFFFu;</div><div class="line">        <span class="keyword">const</span> <span class="keyword">static</span> uint32 INVALID_SLOT = 0xFFFFFFFFu &amp; ((1u &lt;&lt; 29) - 1u);</div><div class="line"></div><div class="line">        FERMAT_HOST_DEVICE CacheInfo() : packed(INVALID) {}</div><div class="line">        FERMAT_HOST_DEVICE CacheInfo(<span class="keyword">const</span> uint32 _packed) : packed(_packed) {}</div><div class="line">        FERMAT_HOST_DEVICE CacheInfo(<span class="keyword">const</span> uint32 _pixel, <span class="keyword">const</span> uint32 _comp, <span class="keyword">const</span> uint32 _new_entry) : pixel(_pixel), <a class="code" href="group___basic.html#gae73662ac7ace330f8b3f726381785f28">comp</a>(_comp), new_entry(_new_entry){}</div><div class="line"></div><div class="line">        FERMAT_HOST_DEVICE</div><div class="line">        <span class="keywordtype">bool</span> is_invalid()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> pixel == INVALID_SLOT; }</div><div class="line"></div><div class="line">        FERMAT_HOST_DEVICE</div><div class="line">        <span class="keywordtype">bool</span> is_valid()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> pixel != INVALID_SLOT; }</div><div class="line"></div><div class="line">        uint32  packed;</div><div class="line">        <span class="keyword">struct</span></div><div class="line">        {</div><div class="line">            uint32 pixel        : 29;</div><div class="line">            uint32 <a class="code" href="group___basic.html#gae73662ac7ace330f8b3f726381785f28">comp</a>         : 2;</div><div class="line">            uint32 new_entry    : 1;</div><div class="line">        };</div><div class="line"></div><div class="line">        FERMAT_HOST_DEVICE <span class="keyword">operator</span> uint32()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> packed; }</div><div class="line">    };</div></div><!-- fragment --> <dl class="section user"><dt></dt><dd>The next method specifies how to compute the Next-Event Estimation weights, separately for diffuse and glossy interactions. Here we have to distinguish a few cases:<ul>
<li>the case where this path vertex comes <b>before</b> any hashing is done (as seen from the eye/camera): in this case we'll do business as usual, compute the weights as one would normally do and simply accumulate the resulting samples directly to the framebuffer (though this is done in a separate method)</li>
<li>the case where this path vertex is <b>the vertex</b> where hashing/filtering is done: in this case, we want to accumulate its <em>demodulated</em> diffuse contribution to the hashmap (where by demodulated we mean that we'll remove any high frequency details introduced by the diffuse texture), while we'll accumulate its glossy contribution directly to the framebuffer (as glossy reflections are generally too high-frequency to be cached and filtered in path space)</li>
<li>the case where this path vertex comes <b>after</b> the vertex where caching is done: in this case again we'll do business as usual in terms of weight calculation, except we'll add both contributions to the corresponding hash cell. </li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd>Again, this method only takes care of computing the weights, while the actual sample accumulations are done in a different method we'll see in a moment. So in practice, as the first and last case result in the same exact weights and only the central case is different, we can group them into two cases only:</dd></dl>
<div class="fragment"><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TPTContext&gt;</div><div class="line">    FERMAT_DEVICE</div><div class="line">    <span class="keywordtype">void</span> compute_nee_weights(</div><div class="line">        <span class="keyword">const</span> TPTContext&amp;           context,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="struct_rendering_context_view.html">RenderingContextView</a>&amp; renderer,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="union_pixel_info.html">PixelInfo</a>             pixel_info,</div><div class="line">        <span class="keyword">const</span> uint32                prev_vertex_info,</div><div class="line">        <span class="keyword">const</span> uint32                vertex_info,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="struct_eye_vertex.html">EyeVertex</a>&amp;            ev,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a>&amp;      f_d,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a>&amp;      f_g,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a>&amp;      w,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a>&amp;      f_L,</div><div class="line">              <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a>&amp;      out_w_d,</div><div class="line">              <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a>&amp;      out_w_g,</div><div class="line">              uint32&amp;               out_vertex_info)</div><div class="line">    {</div><div class="line">        <span class="keyword">const</span> CacheInfo new_cache_info(vertex_info);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">bool</span> new_cache_entry = new_cache_info.new_entry;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> CacheInfo out_cache_info = context.in_bounce &lt; context.options.psf_depth ? CacheInfo(CacheInfo::INVALID) :</div><div class="line">            new_cache_entry ?</div><div class="line">                CacheInfo(new_cache_info.pixel, DIFFUSE_COMP, 0) :  <span class="comment">// cache the diffuse component only</span></div><div class="line">                CacheInfo(new_cache_info.pixel, ALL_COMPS, 0);      <span class="comment">// cache both diffuse and glossy components</span></div><div class="line"></div><div class="line">        out_vertex_info = out_cache_info;</div><div class="line"></div><div class="line">        <span class="comment">// Three cases:</span></div><div class="line">        <span class="comment">//   1. we are not doing any caching:</span></div><div class="line">        <span class="comment">//      1.a: bounce = 0: we will accumulate the diffuse and glossy components separately to the frame-buffer</span></div><div class="line">        <span class="comment">//      1.b: bounce &gt; 0: we will accumulate the sum of the components to a single channel of the frame-buffer</span></div><div class="line">        <span class="comment">//   2. this is a new cache entry (i.e. this is the first D vertex along a path), we demodulate the diffuse BSDF:</span></div><div class="line">        <span class="comment">//          out_w_d = f_d * f_L * G * mis_w</span></div><div class="line">        <span class="comment">//      and accumulate the glossy component to the glossy framebuffer</span></div><div class="line">        <span class="comment">//   3. we are caching both the diffuse and glossy components:</span></div><div class="line">        <span class="comment">//          out_w_d = w * f_d * f_L * G * mis_w,</span></div><div class="line">        <span class="comment">//          out_w_g = w * f_g * f_L * G * mis_w;</span></div><div class="line">        <span class="comment">//      or rather, we could perform a single accumulation using (out_w_d + out_w_g) * f_L * G * mis_w</span></div><div class="line">        <span class="comment">//</span></div><div class="line">        <span class="comment">// Since in practice 1. and 3. end up in the same weights, this reduces to two cases:</span></div><div class="line">        <span class="comment">//   1. this is a new and valid cache entry</span></div><div class="line">        <span class="comment">//   2. all of the others</span></div><div class="line">        <span class="keywordflow">if</span> (new_cache_entry &amp;&amp; out_cache_info.is_valid())</div><div class="line">        {</div><div class="line">            out_w_d = demodulate( f_d, <a class="code" href="structcugar_1_1_vector.html">cugar::Vector4f</a>(ev.material.diffuse).xyz() ) * f_L;</div><div class="line">            out_w_g = f_g * w.xyz() * f_L;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">            out_w_d = f_d * w.xyz() * f_L;</div><div class="line">            out_w_g = f_g * w.xyz() * f_L;</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --> <dl class="section user"><dt></dt><dd>The actual sample accumulation follows from the above mentioned logic. Conceptually, it would be even simpler than it ends up being, except this renderer also keeps track of separate diffuse and glossy channels, which requires some extra special casing based on the path type.</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TPTContext&gt;</div><div class="line">FERMAT_DEVICE</div><div class="line"><span class="keywordtype">void</span> accumulate_nee(</div><div class="line">   <span class="keyword">const</span> TPTContext&amp;           context,</div><div class="line">         <a class="code" href="struct_rendering_context_view.html">RenderingContextView</a>&amp; renderer,</div><div class="line">   <span class="keyword">const</span> <a class="code" href="union_pixel_info.html">PixelInfo</a>             pixel_info,</div><div class="line">   <span class="keyword">const</span> uint32                vertex_info,</div><div class="line">   <span class="keyword">const</span> <span class="keywordtype">bool</span>                  shadow_hit,</div><div class="line">   <span class="keyword">const</span> <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a>&amp;      w_d,</div><div class="line">   <span class="keyword">const</span> <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a>&amp;      w_g)</div><div class="line">{</div><div class="line">   <a class="code" href="struct_f_buffer_view.html">FBufferView</a>&amp; fb = renderer.fb;</div><div class="line">   <a class="code" href="struct_f_buffer_channel_view.html">FBufferChannelView</a>&amp; composited_channel = fb(FBufferDesc::COMPOSITED_C);</div><div class="line">   <a class="code" href="struct_f_buffer_channel_view.html">FBufferChannelView</a>&amp; direct_channel     = fb(FBufferDesc::DIRECT_C);</div><div class="line">   <a class="code" href="struct_f_buffer_channel_view.html">FBufferChannelView</a>&amp; diffuse_channel    = fb(FBufferDesc::DIFFUSE_C);</div><div class="line">   <a class="code" href="struct_f_buffer_channel_view.html">FBufferChannelView</a>&amp; specular_channel   = fb(FBufferDesc::SPECULAR_C);</div><div class="line"></div><div class="line">       <span class="comment">// unpack the pixel index &amp; sampling component</span></div><div class="line">   <span class="keyword">const</span> uint32 pixel_index = pixel_info.pixel;</div><div class="line">   <span class="keyword">const</span> uint32 pixel_comp  = pixel_info.comp;</div><div class="line">   <span class="keyword">const</span> <span class="keywordtype">float</span> frame_weight = context.frame_weight;</div><div class="line"></div><div class="line">   <span class="comment">// access the packed vertex info</span></div><div class="line">   <span class="keyword">const</span> CacheInfo cache_info(vertex_info);</div><div class="line"></div><div class="line">   <span class="keywordflow">if</span> (shadow_hit == <span class="keyword">false</span>)</div><div class="line">   {       </div><div class="line">       <span class="comment">// check if the cache cell is valid</span></div><div class="line">       <span class="keywordflow">if</span> (cache_info.is_valid())</div><div class="line">       {</div><div class="line">           <a href="#Accumulate_selected_components_to_the_cache_cell_anchor">&lt;&lt; Accumulate selected components to the cache cell &gt;&gt;</a></div><div class="line">           <a href="#Accumulate_remainder_to_the_framebuffer_anchor">&lt;&lt; Accumulate remainder to the framebuffer &gt;&gt;</a></div><div class="line">       }</div><div class="line">       <span class="keywordflow">else</span></div><div class="line">       {</div><div class="line">           <a href="#Accumulate_every_component_to_the_framebuffer_anchor">&lt;&lt; Accumulate every component to the framebuffer &gt;&gt;</a></div><div class="line">       }</div><div class="line">   }</div><div class="line">}</div></div><!-- fragment --><dl class="section user"><dt></dt><dd>You can see that there are again basically two cases: the case there is a valid <em>cache_info</em>, specifying a hash cell to accumulate the sample to, and the opposite case, in which the sample has to be accumulated directly to the framebuffer (which might happen if no diffuse vertex has been found along the path, or the required number of bounces for path-space filtering has not yet been reached). In the first case, we need to first determine which components to add the cache - as specified by <em>cache_info.comp</em> - and then issue an atomic for each of the sample value's components. The atomics are needed to make sure conflicting writes to the same cell are appropriately resolved:</dd></dl>
<p><a class="anchor" id="Accumulate_selected_components_to_the_cache_cell_anchor"></a></p><blockquote class="doxtable">
<p><em> <a href="#Accumulate_selected_components_to_the_cache_cell_anchor">&lt;&lt; Accumulate selected components to the cache cell &gt;&gt;</a> := </em></p>
<p></p>
</blockquote>
<div class="fragment"><div class="line">                <span class="keyword">const</span> uint32 cache_slot = cache_info.pixel;</div><div class="line"></div><div class="line">                <span class="comment">// check whether to add both components to the cache or just the diffuse one</span></div><div class="line">                <span class="keyword">const</span> <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a> w = (cache_info.comp == DIFFUSE_COMP) ? w_d : w_d + w_g;</div><div class="line"></div><div class="line">                <a class="code" href="group___atomics.html#ga0c9d949be7ac5b6f27a232c7cd27a05c">cugar::atomic_add</a>(&amp;context.psf_values[cache_slot].x, w.x);</div><div class="line">                <a class="code" href="group___atomics.html#ga0c9d949be7ac5b6f27a232c7cd27a05c">cugar::atomic_add</a>(&amp;context.psf_values[cache_slot].y, w.y);</div><div class="line">                <a class="code" href="group___atomics.html#ga0c9d949be7ac5b6f27a232c7cd27a05c">cugar::atomic_add</a>(&amp;context.psf_values[cache_slot].z, w.z);</div></div><!-- fragment --> <dl class="section user"><dt></dt><dd>In case only the diffuse component was accumulated to the cache cell, we need to add the remaining glossy component to the framebuffer, concluding the treatment of the first case:</dd></dl>
<p><a class="anchor" id="Accumulate_remainder_to_the_framebuffer_anchor"></a></p><blockquote class="doxtable">
<p><em> <a href="#Accumulate_remainder_to_the_framebuffer_anchor">&lt;&lt; Accumulate remainder to the framebuffer &gt;&gt;</a> := </em></p>
<p></p>
</blockquote>
<div class="fragment"><div class="line">                <span class="comment">// if the glossy component was left out, we need to add it to the framebuffer</span></div><div class="line">                <span class="keywordflow">if</span> (cache_info.comp == DIFFUSE_COMP)</div><div class="line">                {</div><div class="line">                    add_in&lt;false&gt;(composited_channel, pixel_index, clamp_sample( w_g ), frame_weight);</div><div class="line"></div><div class="line">                    <span class="comment">// select the right channel</span></div><div class="line">                    <a class="code" href="struct_f_buffer_channel_view.html">FBufferChannelView</a>&amp; fb_channel = context.in_bounce == 0 || (pixel_comp &amp; Bsdf::kGlossyMask) ?</div><div class="line">                        specular_channel :</div><div class="line">                        diffuse_channel;</div><div class="line"></div><div class="line">                    add_in&lt;true&gt;(fb_channel, pixel_index, clamp_sample( w_g ), context.frame_weight);</div><div class="line">                }</div></div><!-- fragment --> <dl class="section user"><dt></dt><dd>The second case is conceptually simpler, and more or less the same of what we did in the standard path tracer:</dd></dl>
<p><a class="anchor" id="Accumulate_every_component_to_the_framebuffer_anchor"></a></p><blockquote class="doxtable">
<p><em> <a href="#Accumulate_every_component_to_the_framebuffer_anchor">&lt;&lt; Accumulate every component to the framebuffer &gt;&gt;</a> := </em></p>
<p></p>
</blockquote>
<div class="fragment"><div class="line">                add_in&lt;false&gt;(composited_channel, pixel_index, clamp_sample( w_d + w_g ), frame_weight);</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> (context.in_bounce == 0)</div><div class="line">                {</div><div class="line">                    <span class="comment">// accumulate the per-component values to the respective output channels</span></div><div class="line">                    add_in&lt;true&gt;(diffuse_channel,  pixel_index, clamp_sample( w_d ), context.frame_weight);</div><div class="line">                    add_in&lt;true&gt;(specular_channel, pixel_index, clamp_sample( w_g ), context.frame_weight);</div><div class="line">                }</div><div class="line">                <span class="keywordflow">else</span></div><div class="line">                {</div><div class="line">                    <span class="comment">// accumulate the aggregate value to the proper output channel (only one will be true)</span></div><div class="line">                    <span class="keywordflow">if</span> (pixel_comp &amp; Bsdf::kDiffuseMask) add_in&lt;true&gt;(diffuse_channel,  pixel_index, clamp_sample( w_d + w_g ), frame_weight);</div><div class="line">                    <span class="keywordflow">if</span> (pixel_comp &amp; Bsdf::kGlossyMask)  add_in&lt;true&gt;(specular_channel, pixel_index, clamp_sample( w_d + w_g ), frame_weight);</div><div class="line">                }</div></div><!-- fragment --> <dl class="section user"><dt></dt><dd>Similar logic applies to the calculation of scattering weights; basically, everything's done as usual in a path tracer, except if we are filtering at the current vertex, in which case we demodulate the weight in order to filter the <em>demodulated</em> path contribution:</dd></dl>
<div class="fragment"><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TPTContext&gt;</div><div class="line">    FERMAT_DEVICE</div><div class="line">    <span class="keywordtype">void</span> compute_scattering_weights(</div><div class="line">        <span class="keyword">const</span> TPTContext&amp;           context,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="struct_rendering_context_view.html">RenderingContextView</a>&amp; renderer,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="union_pixel_info.html">PixelInfo</a>             pixel_info,</div><div class="line">        <span class="keyword">const</span> uint32                prev_vertex_info,</div><div class="line">        <span class="keyword">const</span> uint32                vertex_info,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="struct_eye_vertex.html">EyeVertex</a>&amp;            ev,</div><div class="line">        <span class="keyword">const</span> uint32                out_comp,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a>&amp;      g,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a>&amp;      w,</div><div class="line">              <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a>&amp;      out_w,</div><div class="line">              uint32&amp;               out_vertex_info)</div><div class="line">    {</div><div class="line">        <span class="keyword">const</span> CacheInfo prev_cache_info(prev_vertex_info);</div><div class="line">        <span class="keyword">const</span> CacheInfo new_cache_info(vertex_info);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> uint32 new_cache_slot  = new_cache_info.pixel;</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">bool</span>   new_cache_entry = new_cache_info.new_entry;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> CacheInfo out_cache_info = prev_cache_info.is_invalid() &amp;&amp; (out_comp &amp; Bsdf::kGlossyMask) ?</div><div class="line">            prev_cache_info :                           <span class="comment">// retain the invalid cache location</span></div><div class="line">            CacheInfo(new_cache_slot, ALL_COMPS, 0);    <span class="comment">// cache both diffuse and glossy components</span></div><div class="line"></div><div class="line">        out_vertex_info = out_cache_info;</div><div class="line"></div><div class="line">        <span class="comment">// if this is a new &quot;diffuse cache ray&quot;, i.e. if new_cache_entry &amp;&amp; (out_comp &amp; Bsdf::kDiffuseMask),</span></div><div class="line">        <span class="comment">// we have to demodulate the BSDF weight. This will be compensated by a correctly weighted reference to the queue entry.</span></div><div class="line">        <span class="comment">// The proper solution would be to use SH to encode incoming radiance.</span></div><div class="line">        <span class="keywordflow">if</span> (new_cache_entry &amp;&amp; (out_comp &amp; Bsdf::kDiffuseMask))</div><div class="line">            out_w = demodulate(g, <a class="code" href="structcugar_1_1_vector.html">cugar::Vector4f</a>(ev.material.diffuse).xyz());</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">            out_w = g * w.xyz();</div><div class="line">    }</div></div><!-- fragment --> <dl class="section user"><dt></dt><dd>Finally, the last method prescribes what to do with emissive path vertices, and again we apply a logic similar to the above: if the hash cell computed at the <em>previous</em> path vertex is invalid, we splat the sample directly to the framebuffer, otherwise we splat the sample into the hashmap. The reason why we here look at the previous path vertex is that we are looking at emission at the current vertex towards the previous one, sampling what is basically direct lighting at the previous vertex along the path:</dd></dl>
<div class="fragment"><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TPTContext&gt;</div><div class="line">    FERMAT_DEVICE</div><div class="line">    <span class="keywordtype">void</span> accumulate_emissive(</div><div class="line">        <span class="keyword">const</span> TPTContext&amp;           context,</div><div class="line">              <a class="code" href="struct_rendering_context_view.html">RenderingContextView</a>&amp; renderer,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="union_pixel_info.html">PixelInfo</a>             pixel_info,</div><div class="line">        <span class="keyword">const</span> uint32                prev_vertex_info,</div><div class="line">        <span class="keyword">const</span> uint32                vertex_info,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="struct_eye_vertex.html">EyeVertex</a>&amp;            ev,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a>&amp;      out_w)</div><div class="line">    {</div><div class="line">        <a class="code" href="struct_f_buffer_view.html">FBufferView</a>&amp; fb = renderer.fb;</div><div class="line">        <a class="code" href="struct_f_buffer_channel_view.html">FBufferChannelView</a>&amp; composited_channel = fb(FBufferDesc::COMPOSITED_C);</div><div class="line">        <a class="code" href="struct_f_buffer_channel_view.html">FBufferChannelView</a>&amp; direct_channel     = fb(FBufferDesc::DIRECT_C);</div><div class="line">        <a class="code" href="struct_f_buffer_channel_view.html">FBufferChannelView</a>&amp; diffuse_channel    = fb(FBufferDesc::DIFFUSE_C);</div><div class="line">        <a class="code" href="struct_f_buffer_channel_view.html">FBufferChannelView</a>&amp; specular_channel   = fb(FBufferDesc::SPECULAR_C);</div><div class="line"></div><div class="line">        <span class="comment">// access the vertex info from the previous vertex</span></div><div class="line">        <span class="keyword">const</span> CacheInfo prev_cache_info(prev_vertex_info);</div><div class="line"></div><div class="line">        <span class="comment">// clamp the sample value to avoid extreme fire-flies</span></div><div class="line">        <span class="keyword">const</span> <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a> clamped_out_w = clamp_sample( out_w );</div><div class="line"></div><div class="line">        <span class="comment">// unpack the pixel index &amp; sampling component</span></div><div class="line">        <span class="keyword">const</span> uint32 pixel_index = pixel_info.pixel;</div><div class="line">        <span class="keyword">const</span> uint32 pixel_comp  = pixel_info.comp;</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> frame_weight = context.frame_weight;</div><div class="line"></div><div class="line">        <span class="comment">// accumulate to the image only if prev_cache_info is invalid</span></div><div class="line">        <span class="keywordflow">if</span> (prev_cache_info.is_invalid())</div><div class="line">        {</div><div class="line">            add_in&lt;false&gt;(composited_channel, pixel_index, clamped_out_w, frame_weight);</div><div class="line"></div><div class="line">            <span class="comment">// accumulate the per-component value to the proper output channel</span></div><div class="line">            <span class="keywordflow">if</span> (context.in_bounce == 0)</div><div class="line">                add_in&lt;false&gt;(direct_channel, pixel_index, clamped_out_w, frame_weight);</div><div class="line">            <span class="keywordflow">else</span></div><div class="line">            {</div><div class="line">                <span class="keywordflow">if</span> (pixel_comp &amp; Bsdf::kDiffuseMask) add_in&lt;true&gt;(diffuse_channel,  pixel_index, clamped_out_w, frame_weight);</div><div class="line">                <span class="keywordflow">if</span> (pixel_comp &amp; Bsdf::kGlossyMask)  add_in&lt;true&gt;(specular_channel, pixel_index, clamped_out_w, frame_weight);</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span> </div><div class="line">        {</div><div class="line">            <span class="comment">// accumulate to the cache entry</span></div><div class="line">            <a class="code" href="group___atomics.html#ga0c9d949be7ac5b6f27a232c7cd27a05c">cugar::atomic_add</a>(&amp;context.psf_values[prev_cache_info.pixel].x, clamped_out_w.x);</div><div class="line">            <a class="code" href="group___atomics.html#ga0c9d949be7ac5b6f27a232c7cd27a05c">cugar::atomic_add</a>(&amp;context.psf_values[prev_cache_info.pixel].y, clamped_out_w.y);</div><div class="line">            <a class="code" href="group___atomics.html#ga0c9d949be7ac5b6f27a232c7cd27a05c">cugar::atomic_add</a>(&amp;context.psf_values[prev_cache_info.pixel].z, clamped_out_w.z);</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --> <dl class="section user"><dt></dt><dd>Here we go, this is pretty much all the magic needed to perform path space filtering within our <a class="el" href="group___p_t_lib.html">PTLib</a> framework. Hopefully, this speaks to its flexibility... <br />
 Of course, there's many important details we just skimmed over, like the actual implementation of the massively parallel hashmap, but thankfully this is all provided by the underlying <a class="el" href="cugar_page.html">CUGAR</a> library.</dd></dl>
<dl class="section user"><dt></dt><dd>So here's a comparison of what you get with standard path tracing (top), and path-space filtering (bottom) at 32 samples per pixel. Ideally, you should also think this coding excercise was worth the effort. <div class="image">
<img src="pt-32.jpg" style="position:relative; bottom:-10px; border:0px; width:760px;"/>
</div>
 <br />
 <div class="image">
<img src="psfpt-32.jpg" style="position:relative; bottom:-10px; border:0px; width:760px;"/>
</div>
 <br />
</dd></dl>
<p>Next: <a class="el" href="_b_p_t_lib_page.html">BPTLib</a> </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
