<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>Fermat: An Overture</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">
    (function(i, s, o, g, r, a, m) {
        i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function() {
            (i[r].q = i[r].q || []).push(arguments)
        }, i[r].l = 1 * new Date(); a = s.createElement(o),
  m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
    })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');
    ga('create', 'UA-47310325-1', 'nvlabs.github.io');
    ga('send', 'pageview');
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Fermat
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">An Overture </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Top: <a class="el" href="_overture_contents_page.html">Contents</a></p>
<div class="image">
<img src="morning-coffee-bath.jpg" style="position:relative; bottom:-10px; border:0px; width:760px;"/>
</div>
 <dl class="section user"><dt></dt><dd><small>'Salle de bain, with coffee', based on a <a href="http://www.blendswap.com/blends/view/73937">model</a> by <em>nacimus</em></small> <br />
</dd></dl>
<dl class="section user"><dt></dt><dd>Building a physically based renderer is a subject that has already been covered by a couple great books (for example, the fantastic <a href="http://www.pbr-book.org">PBR</a>). Building a high performance, massively parallel renderer is a slightly different topic, that so far has not received much attention. While <a class="el" href="group___fermat.html">Fermat</a> doesn't pretend to be a full featured rendering system, it tries to show how to go about writing one. Here, we will try to go a little bit into its details. </dd></dl>
<dl class="section user"><dt></dt><dd>Like many books out there, this overture should probably start from the ground up, describing the very basics of geometry on which the renderer is built. Since many books have already covered that subject, however, and as the vector and matrix classes used in Fermat are likely not very different from any of the others, we will just skip that part and jump onto the more interesting, rendering-related stuff. As a matter of fact, Fermat itself relies on a separate library for all of those ancillary classes and utilities: <a class="el" href="cugar_page.html">CUGAR</a>. </dd></dl>
<dl class="section user"><dt></dt><dd>The one thing we will need, however, is a short digression into the <em>host</em> and <em>device</em> dichotomy present throughout all of Fermat, which is, mostly, a <em>GPU</em> renderer. In order to understand the consequences of this dichotomy, and in particular the one between the host and device memory spaces, you should go straight to this page and come back when you are done with it: <a class="el" href="_fermat_host_device_page.html">Host &amp; Device</a>.</dd></dl>
<dl class="section user"><dt></dt><dd>So what is Fermat, exactly? Perhaps, the most concise explanation is that it is a collection of <em>path samplers</em> of various kinds. Like all modern physically based renderers, all of Fermat's internal rendering algorithms follow the same old recipe: throw some more or less random numbers, <em>sample</em> more or less <em>interesting light paths</em>, connecting the emitters to the eye of the virtual observer, and calculate and <em>average</em> the radiance that flows through them. This, plus or minus some denoising. </dd></dl>
<dl class="section user"><dt></dt><dd>In fact, the only useful bit of basic geometry we need in order to proceed is the concept of differential vertex geometry needed to represent light path vertices. Fermat employs the following simple representation: <br />
<div class="fragment"><div class="line"><span class="comment">// Vertex geometry.</span></div><div class="line"><span class="comment">// </span></div><div class="line"><span class="comment">// Encodes the local differential surface geometry at a point, including its tangent, binormal</span></div><div class="line"><span class="comment">// and normal, as well the local texture coordinates.</span></div><div class="line"><span class="comment">// </span></div><div class="line"><span class="keyword">struct </span><a class="code" href="struct_vertex_geometry.html">VertexGeometry</a></div><div class="line">{</div><div class="line">   <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a> normal_s;           <span class="comment">// shading normal</span></div><div class="line">   <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a> normal_g;           <span class="comment">// geometric normal</span></div><div class="line">   <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a> tangent;            <span class="comment">// local tangent</span></div><div class="line">   <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a> binormal;           <span class="comment">// local binormal</span></div><div class="line"></div><div class="line">   <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a> position;           <span class="comment">// local position</span></div><div class="line">   <span class="keywordtype">float</span>           padding;            <span class="comment">// some padding</span></div><div class="line">   <a class="code" href="structcugar_1_1_vector.html">cugar::Vector4f</a> texture_coords;     <span class="comment">// local texture coordinates (2 sets)</span></div><div class="line">   <a class="code" href="structcugar_1_1_vector.html">cugar::Vector2f</a> lightmap_coords;    <span class="comment">// local lightmap coordinates</span></div><div class="line">};</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>The next question we need to answer when writing a renderer is: how exactly do you sample light paths? That turns out to be the subject of most rendering research of the last 20 years. In fact, if you do not know the basics already, the best possible source of information is still Eric Veach's <a href="http://graphics.stanford.edu/papers/veach_thesis/">master thesis</a> from 1997, a work of rare and exceptional clarity, that literally laid the groundwork for this entire field. Again, Fermat just tries to summarize a few of the most widely spread and a few of the most recent algorithms, while focusing on doing that <em>efficiently</em>. </dd></dl>
<dl class="section user"><dt></dt><dd>Getting to the point where we can actually describe how that is performed will require some time, but overall it all starts from four basic ingredients: <br />
<ul>
<li>the virtual camera,</li>
<li>the Bidirectional Scattering Distribution Function, or <em>BSDF</em>,</li>
<li>the light sources, or <em>emitters</em>,</li>
<li>and obviously, the scene geometry, or <em>meshes</em>, </li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd>And this is exactly what we'll cover in the next few sections.</dd></dl>
<h1><a class="anchor" id="MeshesSection"></a>
The Mesh Geometry</h1>
<dl class="section user"><dt></dt><dd>If we want to see something in our pictures, we need some geometry for light to bounce against. In order to keep things simple, Fermat supports only one type: <em>triangle meshes</em>. The internal representation is the fairly typical one of indexed triangles, where the vertices together with their normals and texture coordinates are given in separate arrays, and yet another array provides the list of triangles as triplets of indices into the vertex and attribute lists. </dd></dl>
<dl class="section user"><dt></dt><dd>In practice it is all encapsulated behind a few interfaces. The first two are the classes reponsible for holding and owning the actual mesh <em>storage</em>, used on the host-side of things (i.e. on the CPU): <a class="el" href="class_mesh_storage.html">MeshStorage</a>, to allocate and hold a mesh in host memory, and <a class="el" href="class_device_mesh_storage.html">DeviceMeshStorage</a>, to allocate and hold a mesh in device memory (i.e. the GPU). The third interface, <a class="el" href="struct_mesh_view.html">MeshView</a>, is what we call a <a class="el" href="_fermat_host_device_page.html#FermatPlainViewsSection">view</a> of the mesh: a thin class used to simply access the mesh representation, without actually owning any of its data - in practice, the moral equivalent of a pointer. This is what can be passed to device kernels to retrieve any of the relative information (without the need to dereference an <em>actual</em> pointer, which would require an expensive host memory access). </dd></dl>
<dl class="section user"><dt></dt><dd>Without going into the details of its internals, we can list the free functions which provide access to its raw vertex data: <br />
<div class="fragment"><div class="line"><span class="comment">// helper method to fetch a vertex</span></div><div class="line"><span class="comment">//</span></div><div class="line">FERMAT_HOST_DEVICE FERMAT_FORCEINLINE</div><div class="line"><span class="keyword">const</span> MeshView::vertex_type&amp; <a class="code" href="group___mesh_module.html#ga4b65791b4c323a93e391c4c2e88cd601">fetch_vertex</a>(<span class="keyword">const</span> <a class="code" href="struct_mesh_view.html">MeshView</a>&amp; mesh, <span class="keyword">const</span> uint32 vertex_idx);</div><div class="line"></div><div class="line"><span class="comment">// helper method to fetch a normal vertex</span></div><div class="line"><span class="comment">//</span></div><div class="line">FERMAT_HOST_DEVICE FERMAT_FORCEINLINE</div><div class="line"><span class="keyword">const</span> MeshView::normal_type&amp; <a class="code" href="group___mesh_module.html#ga2d3d06537c1b2fc31399190bd353f6e6">fetch_normal</a>(<span class="keyword">const</span> <a class="code" href="struct_mesh_view.html">MeshView</a>&amp; mesh, <span class="keyword">const</span> uint32 vertex_idx);</div><div class="line"></div><div class="line"><span class="comment">// helper method to fetch a texture coordinate vertex</span></div><div class="line"><span class="comment">//</span></div><div class="line">FERMAT_HOST_DEVICE FERMAT_FORCEINLINE</div><div class="line"><span class="keyword">const</span> MeshView::texture_coord_type&amp; <a class="code" href="group___mesh_module.html#gae33ea9281c4276a5132e37c0b1331069">fetch_tex_coord</a>(<span class="keyword">const</span> <a class="code" href="struct_mesh_view.html">MeshView</a>&amp; mesh, <span class="keyword">const</span> uint32 vertex_idx);</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>the functions to access the triangle lists: <br />
<div class="fragment"><div class="line"><span class="comment">// helper method to fetch the vertex indices of a given triangle</span></div><div class="line"><span class="comment">//</span></div><div class="line">FERMAT_HOST_DEVICE FERMAT_FORCEINLINE</div><div class="line">int3 <a class="code" href="group___mesh_module.html#ga50a8be2a2adb88816865cbd13a5aab57">load_vertex_triangle</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>* triangle_indices, <span class="keyword">const</span> uint32 tri_idx);</div><div class="line"></div><div class="line"><span class="comment">// helper method to fetch the normal indices of a given triangle</span></div><div class="line"><span class="comment">//</span></div><div class="line">FERMAT_HOST_DEVICE FERMAT_FORCEINLINE</div><div class="line">int3 <a class="code" href="group___mesh_module.html#ga85e3684bd6c76144d9dc00a2b59cf93f">load_normal_triangle</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>* triangle_indices, <span class="keyword">const</span> uint32 tri_idx);</div><div class="line"></div><div class="line"><span class="comment">// helper method to fetch the texture coordinate indices of a given triangle</span></div><div class="line"><span class="comment">//</span></div><div class="line">FERMAT_HOST_DEVICE FERMAT_FORCEINLINE</div><div class="line">int3 <a class="code" href="group___mesh_module.html#ga347e9722a85a86f87f7d31a63f333dd5">load_texture_triangle</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>* triangle_indices, <span class="keyword">const</span> uint32 tri_idx);</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>and the utilities to <em>compute</em> useful information about local triangle geometry: <br />
<div class="fragment"><div class="line"><span class="comment">// return the area of a given primitive</span></div><div class="line"><span class="comment">//</span></div><div class="line">FERMAT_HOST_DEVICE <span class="keyword">inline</span></div><div class="line"><span class="keywordtype">float</span> <a class="code" href="group___mesh_module.html#ga516a7610fe394a18d5083aa21f6cda75">prim_area</a>(<span class="keyword">const</span> <a class="code" href="struct_mesh_view.html">MeshView</a>&amp; mesh, <span class="keyword">const</span> uint32 tri_id);</div><div class="line"></div><div class="line"><span class="comment">// return the differential geometry of a given point on the mesh, specified by a (prim_id, uv) pair</span></div><div class="line"><span class="comment">//</span></div><div class="line">FERMAT_HOST_DEVICE <span class="keyword">inline</span></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="group___mesh_module.html#ga4fa88a02d11b01ea12e6a602b3e3e5c2">setup_differential_geometry</a>(</div><div class="line">       <span class="keyword">const</span> <a class="code" href="struct_mesh_view.html">MeshView</a>&amp;         mesh,</div><div class="line">       <span class="keyword">const</span> <a class="code" href="struct_vertex_geometry_id.html">VertexGeometryId</a>  v,</div><div class="line">       <a class="code" href="struct_vertex_geometry.html">VertexGeometry</a>*         geom,</div><div class="line">       <span class="keywordtype">float</span>*                  pdf = 0);</div><div class="line"></div><div class="line"><span class="comment">// return the interpolated position at a given point on the mesh, specified by a (prim_id, uv) pair</span></div><div class="line"><span class="comment">//</span></div><div class="line">FERMAT_HOST_DEVICE <span class="keyword">inline</span></div><div class="line"><a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a> <a class="code" href="group___mesh_module.html#ga9eea5d10bfff40b7f050910a97212189">interpolate_position</a>(<span class="keyword">const</span> <a class="code" href="struct_mesh_view.html">MeshView</a>&amp; mesh, <span class="keyword">const</span> <a class="code" href="struct_vertex_geometry_id.html">VertexGeometryId</a> v, <span class="keywordtype">float</span>* pdf = 0);</div><div class="line"></div><div class="line"><span class="comment">// return the interpolated normal at a given point on the mesh, specified by a (prim_id, uv) pair</span></div><div class="line"><span class="comment">//</span></div><div class="line">FERMAT_HOST_DEVICE <span class="keyword">inline</span></div><div class="line"><a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a> <a class="code" href="group___mesh_module.html#gac16c0ec581833a6cf3f821d0edeb698b">interpolate_normal</a>(<span class="keyword">const</span> <a class="code" href="struct_mesh_view.html">MeshView</a>&amp; mesh, <span class="keyword">const</span> <a class="code" href="struct_vertex_geometry_id.html">VertexGeometryId</a> v, <span class="keyword">const</span> <span class="keywordtype">float</span> v);</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>A complete list of the available functions can be found in the <a class="el" href="group___mesh_module.html">MeshModule</a>. </dd></dl>
<dl class="section user"><dt></dt><dd>Notice how each point on the mesh surface is addressed by a small data structure, that compactly encodes all the necessary information needed to uniquely identify the point: <br />
<div class="fragment"><div class="line"><span class="comment">// </span></div><div class="line"><span class="comment">// Encodes the minimal amount of information needed to represent a point on a surface,</span></div><div class="line"><span class="comment">// or a &lt;i&gt;hit&lt;/i&gt; in ray tracing parlance</span></div><div class="line"><span class="comment">// </span></div><div class="line"><span class="keyword">struct </span><a class="code" href="struct_vertex_geometry_id.html">VertexGeometryId</a></div><div class="line">{</div><div class="line">   <a class="code" href="structcugar_1_1_vector.html">cugar::Vector2f</a> uv;</div><div class="line">   uint32          prim_id;</div><div class="line"></div><div class="line">   FERMAT_HOST_DEVICE</div><div class="line">   <a class="code" href="struct_vertex_geometry_id.html">VertexGeometryId</a>() {}</div><div class="line"></div><div class="line">   FERMAT_HOST_DEVICE</div><div class="line">   <a class="code" href="struct_vertex_geometry_id.html">VertexGeometryId</a>(<span class="keyword">const</span> uint32 _prim_id, <span class="keyword">const</span> <span class="keywordtype">float</span> _u, <span class="keyword">const</span> <span class="keywordtype">float</span> _v) : prim_id(_prim_id), uv(_u, _v) {}</div><div class="line"></div><div class="line">   FERMAT_HOST_DEVICE</div><div class="line">   <a class="code" href="struct_vertex_geometry_id.html">VertexGeometryId</a>(<span class="keyword">const</span> uint32 _prim_id, <span class="keyword">const</span> <a class="code" href="structcugar_1_1_vector.html">cugar::Vector2f</a> _uv) : prim_id(_prim_id), uv(_uv) {}</div><div class="line">};</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>In fact, one of the tricks to high performance rendering is tightly packing <em>all</em> information, so as to consume as little bandwith and on-chip memory as possible, and this is just one of the many examples you'll find in Fermat.</dd></dl>
<h1><a class="anchor" id="CameraSection"></a>
The Camera Model</h1>
<dl class="section user"><dt></dt><dd>Simulating a realistic camera accurately (as needed for example to match live action film) can by itself be a rather complex subject. Currently, Fermat doesn't attempt to do that, and simply models an infinitely thin pinhole camera. So simple, in fact, that it can be described by a handful of vectors and a single scalar: <br />
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="struct_camera.html">Camera</a></div><div class="line">{</div><div class="line">    float3  eye;    <span class="comment">// the eye position</span></div><div class="line">    float3  aim;    <span class="comment">// the aim position</span></div><div class="line">    float3  up;     <span class="comment">// a vector specifying where the upwards direction is relative to the camera frame</span></div><div class="line">    float3  dx;     <span class="comment">// a vector specifying where the right is relative to the camera frame</span></div><div class="line">    <span class="keywordtype">float</span>   fov;    <span class="comment">// the field of view</span></div><div class="line">};</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>Together with the camera itself, Fermat also provides a utility <a class="el" href="struct_camera_sampler.html">CameraSampler</a> class: <br />
<div class="fragment"><div class="line"><span class="comment">// A sampler for the pinhole camera model</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">struct </span><a class="code" href="struct_camera_sampler.html">CameraSampler</a></div><div class="line">{</div><div class="line">   <span class="comment">// empty constructor</span></div><div class="line">   <span class="comment">//</span></div><div class="line">   FERMAT_HOST_DEVICE</div><div class="line">   <a class="code" href="struct_camera_sampler.html#a50332d884a007ab1ffcb05215af5d92a">CameraSampler</a>() {}</div><div class="line"></div><div class="line">   FERMAT_HOST_DEVICE</div><div class="line">   <a class="code" href="struct_camera_sampler.html#a50332d884a007ab1ffcb05215af5d92a">CameraSampler</a>(<span class="keyword">const</span> <a class="code" href="struct_camera.html">Camera</a>&amp; camera, <span class="keyword">const</span> <span class="keywordtype">float</span> aspect_ratio);</div><div class="line"></div><div class="line">   <span class="comment">// sample a direction from normalized device coordinates (NDC) in [0,1]^2</span></div><div class="line">   <span class="comment">//</span></div><div class="line">   FERMAT_HOST_DEVICE</div><div class="line">   <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a> <a class="code" href="struct_camera_sampler.html#ac502e1699c99c595b773b1419225fe32">sample_direction</a>(<span class="keyword">const</span> <a class="code" href="structcugar_1_1_vector.html">cugar::Vector2f</a> ndc) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">   <span class="comment">// compute the direction pdf</span></div><div class="line">   <span class="comment">//</span></div><div class="line">   <span class="comment">// \param dir               the given direction</span></div><div class="line">   <span class="comment">// \param projected         whether to return the pdf in projected solid angle or solid angle measure</span></div><div class="line">   FERMAT_HOST_DEVICE</div><div class="line">   <span class="keywordtype">float</span> <a class="code" href="struct_camera_sampler.html#a0edd94ccee6da3180f13845d189bc758">pdf</a>(<span class="keyword">const</span> <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a> direction, <span class="keyword">const</span> <span class="keywordtype">bool</span> projected = <span class="keyword">false</span>) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">   <span class="comment">// invert the camera direction sampler</span></div><div class="line">   <span class="comment">//</span></div><div class="line">   <span class="comment">// \param dir               the given direction</span></div><div class="line">   <span class="comment">// \return                  the NDC coordinates corresponding to the given direction</span></div><div class="line">   FERMAT_HOST_DEVICE</div><div class="line">   <a class="code" href="structcugar_1_1_vector.html">cugar::Vector2f</a> <a class="code" href="struct_camera_sampler.html#a347623323319a7111f933d4af6ac2d19">invert</a>(<span class="keyword">const</span> <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a> dir) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">   <span class="comment">// invert the camera direction sampler and compute its projected solid angle pdf</span></div><div class="line">   <span class="comment">//</span></div><div class="line">   <span class="comment">// \param dir               the given direction</span></div><div class="line">   <span class="comment">// \param projected         whether to return the pdf in projected solid angle or solid angle measure</span></div><div class="line">   <span class="comment">// \return                  the NDC coordinates corresponding to the given direction</span></div><div class="line">   FERMAT_HOST_DEVICE</div><div class="line">   <a class="code" href="structcugar_1_1_vector.html">cugar::Vector2f</a> <a class="code" href="struct_camera_sampler.html#a347623323319a7111f933d4af6ac2d19">invert</a>(<span class="keyword">const</span> <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a> dir, <span class="keywordtype">float</span>* pdf_proj) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">   <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a> U;                      <span class="comment">// camera space +X axis in world coords</span></div><div class="line">   <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a> V;                      <span class="comment">// camera space +Y axis in world coords</span></div><div class="line">   <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a> W;                      <span class="comment">// camera space +Z axis in world coords</span></div><div class="line">   <span class="keywordtype">float</span>           W_len;                  <span class="comment">// precomputed length of the W vector</span></div><div class="line">   <span class="keywordtype">float</span>           square_focal_length;    <span class="comment">// square focal length</span></div><div class="line">};</div></div><!-- fragment --></dd></dl>
<h1><a class="anchor" id="BSDFSection"></a>
The BSDF Model</h1>
<dl class="section user"><dt></dt><dd>Again, a whole book could be easily dedicated to the subject of properly simulating realistic BSDFs. Fermat does take some shortcuts there, and focuses on a single, monolithic, layered BSDF model. It is <em>very</em> simple, and yet expressive enough to represent a decent spectrum of the materials we see in everday's life. It contains four basic components: </dd></dl>
<dl class="section user"><dt></dt><dd><ul>
<li>a diffuse reflection component</li>
<li>a diffuse transmission component</li>
<li>a glossy reflection component layered on top of the diffuse layer</li>
<li>a glossy transmission component layered on top of the diffuse layer </li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd>The diffuse components are purely Lambertian, while the glossy components are based on the GGX model with Smith's joint masking-shadowing function described in: <blockquote class="doxtable">
<p>[Heitz 2014, "Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs"] </p>
</blockquote>
</dd></dl>
<dl class="section user"><dt></dt><dd>The BSDF uses Fresnel coefficients to determine how much light undergoes glossy reflection, and how much undergoes transmission. Part of the radiance transmitted from the upper glossy layer undergoes diffuse scattering. The interaction between the glossy layer and the underlying diffuse layer is modeled in a simplified manner, as if the layer was infinitely thin and the diffusely reflected particles were not interacting again with the upper layer. </dd></dl>
<dl class="section user"><dt></dt><dd>Its basic interface looks like this: <br />
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="struct_bsdf.html">Bsdf</a></div><div class="line">{</div><div class="line">   <span class="comment">// component type bitmasks</span></div><div class="line">   <span class="comment">//</span></div><div class="line">   <span class="keyword">enum</span> <a class="code" href="struct_bsdf.html#a5f7db6f81220ed9ee6da109d6eb5b585">ComponentType</a></div><div class="line">   {</div><div class="line">       kAbsorption             = 0u,</div><div class="line"></div><div class="line">       kDiffuseReflection      = 0x1u,</div><div class="line">       kDiffuseTransmission    = 0x2u,</div><div class="line">       kGlossyReflection       = 0x4u,</div><div class="line">       kGlossyTransmission     = 0x8u,</div><div class="line"></div><div class="line">       kDiffuseMask            = 0x3u,</div><div class="line">       kGlossyMask             = 0xCu,</div><div class="line"></div><div class="line">       kReflectionMask         = 0x5u,</div><div class="line">       kTransmissionMask       = 0xAu,</div><div class="line">       kAllComponents          = 0xFFu</div><div class="line">   };</div><div class="line"></div><div class="line">   <span class="keyword">typedef</span> <a class="code" href="structcugar_1_1_lambert_trans_bsdf.html">cugar::LambertTransBsdf</a> diffuse_trans_component;</div><div class="line">   <span class="keyword">typedef</span> <a class="code" href="structcugar_1_1_lambert_bsdf.html">cugar::LambertBsdf</a>      diffuse_component;</div><div class="line">   <span class="keyword">typedef</span> <a class="code" href="structcugar_1_1_g_g_x_smith_bsdf.html">cugar::GGXSmithBsdf</a>     glossy_component;</div><div class="line"></div><div class="line">   <span class="comment">// evaluate the BSDF f(V,L)</span></div><div class="line">   <span class="comment">//</span></div><div class="line">   <span class="comment">// \param geometry              the local differential geometry</span></div><div class="line">   <span class="comment">// \param in                    the incoming direction</span></div><div class="line">   <span class="comment">// \param out                   the outgoing direction</span></div><div class="line">   <span class="comment">// \param components            the components to consider</span></div><div class="line">   FERMAT_FORCEINLINE FERMAT_HOST_DEVICE</div><div class="line">   <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a> <a class="code" href="struct_bsdf.html#a58f402b71508cb422ebe3f0e628fd2fd">f</a>(</div><div class="line">       <span class="keyword">const</span> <a class="code" href="structcugar_1_1_differential_geometry.html">cugar::DifferentialGeometry</a>&amp;  geometry,</div><div class="line">       <span class="keyword">const</span> <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a>               in,</div><div class="line">       <span class="keyword">const</span> <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a>               out,</div><div class="line">       <span class="keyword">const</span> <a class="code" href="struct_bsdf.html#a5f7db6f81220ed9ee6da109d6eb5b585">ComponentType</a>                 components) <span class="keyword">const</span></div><div class="line"></div><div class="line">   <span class="comment">// evaluate the total projected probability density p(V,L) = p(L|V)</span></div><div class="line">   <span class="comment">//</span></div><div class="line">   <span class="comment">// \param geometry              the local differential geometry</span></div><div class="line">   <span class="comment">// \param in                    the incoming direction</span></div><div class="line">   <span class="comment">// \param out                   the outgoing direction</span></div><div class="line">   <span class="comment">// \param measure               the spherical measure to use</span></div><div class="line">   <span class="comment">// \param RR                    indicate whether to use Russian-Roulette or not</span></div><div class="line">   <span class="comment">// \param components            the components to consider</span></div><div class="line">   FERMAT_FORCEINLINE FERMAT_HOST_DEVICE</div><div class="line">   <span class="keywordtype">float</span> <a class="code" href="struct_bsdf.html#a88c3b1f89a3248d4b2684fd402a59ced">p</a>(</div><div class="line">       <span class="keyword">const</span> <a class="code" href="structcugar_1_1_differential_geometry.html">cugar::DifferentialGeometry</a>&amp;  geometry,</div><div class="line">       <span class="keyword">const</span> <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a>               in,</div><div class="line">       <span class="keyword">const</span> <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a>               out,</div><div class="line">       <span class="keyword">const</span> cugar::SphericalMeasure       measure,</div><div class="line">       <span class="keyword">const</span> <span class="keywordtype">bool</span>                          RR,</div><div class="line">       <span class="keyword">const</span> <a class="code" href="struct_bsdf.html#a5f7db6f81220ed9ee6da109d6eb5b585">ComponentType</a>                 components) <span class="keyword">const</span></div><div class="line"></div><div class="line">   <span class="comment">// sample an outgoing direction</span></div><div class="line">   <span class="comment">//</span></div><div class="line">   <span class="comment">// \param geometry              the local differential geometry</span></div><div class="line">   <span class="comment">// \param z                     the incoming direction</span></div><div class="line">   <span class="comment">// \param in                    the incoming direction</span></div><div class="line">   <span class="comment">// \param out_comp              the output component</span></div><div class="line">   <span class="comment">// \param out                   the outgoing direction</span></div><div class="line">   <span class="comment">// \param out_p                 the output solid angle pdf</span></div><div class="line">   <span class="comment">// \param out_p_proj            the output projected solid angle pdf</span></div><div class="line">   <span class="comment">// \param out_g                 the output sample value = f/p_proj</span></div><div class="line">   <span class="comment">// \param RR                    indicate whether to use Russian-Roulette or not</span></div><div class="line">   <span class="comment">// \param evaluate_full_bsdf    indicate whether to evaluate the full BSDF, or just an unbiased estimate</span></div><div class="line">   <span class="comment">// \param components            the components to consider</span></div><div class="line">   FERMAT_HOST_DEVICE FERMAT_FORCEINLINE</div><div class="line">   <span class="keywordtype">bool</span> <a class="code" href="struct_bsdf.html#ac4ce2cad14795e1ff7f82ed10990ba3e">sample</a>(</div><div class="line">       <span class="keyword">const</span> <a class="code" href="structcugar_1_1_differential_geometry.html">cugar::DifferentialGeometry</a>&amp;  geometry,</div><div class="line">       <span class="keyword">const</span> <span class="keywordtype">float</span>                         z[3],</div><div class="line">       <span class="keyword">const</span> <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a>               in,</div><div class="line">       <a class="code" href="struct_bsdf.html#a5f7db6f81220ed9ee6da109d6eb5b585">ComponentType</a>&amp;                      out_comp,</div><div class="line">       <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a>&amp;                    out,</div><div class="line">       <span class="keywordtype">float</span>&amp;                              out_p,</div><div class="line">       <span class="keywordtype">float</span>&amp;                              out_p_proj,</div><div class="line">       <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a>&amp;                    out_g,</div><div class="line">       <span class="keywordtype">bool</span>                                RR,</div><div class="line">       <span class="keywordtype">bool</span>                                evaluate_full_bsdf,</div><div class="line">       <span class="keyword">const</span> <a class="code" href="struct_bsdf.html#a5f7db6f81220ed9ee6da109d6eb5b585">ComponentType</a>                 components) <span class="keyword">const</span></div><div class="line">};</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>In the actual <a class="el" href="struct_bsdf.html">Bsdf</a> class, a few more methods are present to calculate f() and p() at the same time, and to calculate both component-by-component, all in one go, as well as auxiliary methods to compute the Fresnel weights associated with each layer.</dd></dl>
<h1><a class="anchor" id="LightSection"></a>
The Light Source Model</h1>
<dl class="section user"><dt></dt><dd>In nature, light sources are just emissive geometry. Fermat supports both emissive geometry and a bunch of other <em>primitive</em> light sources, including some that have a singular distribution (e.g. directional lights), or others that provide good analytic sampling algorithms. All of them respond to a single <a class="el" href="struct_light.html">Light</a> interface that provides basic methods to point-sample the light source surface, and query the Emission Distribution Function, or <em>EDF</em>, at each point. The basic interface is the following: <br />
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="struct_light.html">Light</a></div><div class="line">{</div><div class="line">   <span class="comment">// sample a point on the light source, given 3 random numbers</span></div><div class="line">   <span class="comment">//</span></div><div class="line">   <span class="comment">// \param Z             the input random numbers</span></div><div class="line">   <span class="comment">// \param prim_id       the output primitive index, in case the light is made of a mesh</span></div><div class="line">   <span class="comment">// \param uv            the output uv coordinates on the sampled primitive</span></div><div class="line">   <span class="comment">// \param geom          the output sample&#39;s differential geometry</span></div><div class="line">   <span class="comment">// \param pdf           the output sample&#39;s area pdf</span></div><div class="line">   <span class="comment">// \param edf           the output sample&#39;s EDF</span></div><div class="line">   <span class="comment">//</span></div><div class="line">   <span class="comment">// \return true iff the pdf is singular</span></div><div class="line">   FERMAT_HOST_DEVICE</div><div class="line">   <span class="keywordtype">bool</span> <a class="code" href="group___lights_module.html#ga67cc240bcda4b08efd26c8727144bf16">sample</a>(</div><div class="line">       <span class="keyword">const</span> <span class="keywordtype">float</span>*        Z,</div><div class="line">       uint32_t*           prim_id,</div><div class="line">       <a class="code" href="structcugar_1_1_vector.html">cugar::Vector2f</a>*    uv,</div><div class="line">       <a class="code" href="struct_vertex_geometry.html">VertexGeometry</a>*     geom,</div><div class="line">       <span class="keywordtype">float</span>*              pdf,</div><div class="line">       <a class="code" href="struct_edf.html">Edf</a>*                edf) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">   <span class="comment">// sample a point on the light source given a selected shading point (or receiver)</span></div><div class="line">   <span class="comment">//</span></div><div class="line">   <span class="comment">// \param p             the input shading point</span></div><div class="line">   <span class="comment">// \param Z             the input random numbers</span></div><div class="line">   <span class="comment">// \param prim_id       the output primitive index, in case the light is made of a mesh</span></div><div class="line">   <span class="comment">// \param uv            the output uv coordinates on the sampled primitive</span></div><div class="line">   <span class="comment">// \param geom          the output sample&#39;s differential geometry</span></div><div class="line">   <span class="comment">// \param pdf           the output sample&#39;s area pdf</span></div><div class="line">   <span class="comment">// \param edf           the output sample&#39;s EDF</span></div><div class="line">   <span class="comment">//</span></div><div class="line">   <span class="comment">// \return true iff the pdf is singular</span></div><div class="line">   FERMAT_HOST_DEVICE</div><div class="line">   <span class="keywordtype">bool</span> <a class="code" href="group___lights_module.html#ga67cc240bcda4b08efd26c8727144bf16">sample</a>(</div><div class="line">       <span class="keyword">const</span> <a class="code" href="structcugar_1_1_vector.html">cugar::Vector3f</a>   p,</div><div class="line">       <span class="keyword">const</span> <span class="keywordtype">float</span>*            Z,</div><div class="line">       uint32_t*               prim_id,</div><div class="line">       <a class="code" href="structcugar_1_1_vector.html">cugar::Vector2f</a>*        uv,</div><div class="line">       <a class="code" href="struct_vertex_geometry.html">VertexGeometry</a>*         geom,</div><div class="line">       <span class="keywordtype">float</span>*                  pdf,</div><div class="line">       <a class="code" href="struct_edf.html">Edf</a>*                    edf) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">   <span class="comment">// intersect the given ray with the light source</span></div><div class="line">   <span class="comment">//</span></div><div class="line">   <span class="comment">// \param ray           the input ray</span></div><div class="line">   <span class="comment">// \param uv            the output uv coordinates on the sampled primitive</span></div><div class="line">   <span class="comment">// \param t             the output ray intersection distance</span></div><div class="line">   <span class="comment">//</span></div><div class="line">   FERMAT_HOST_DEVICE</div><div class="line">   <span class="keywordtype">void</span> <a class="code" href="group___lights_module.html#ga6a7452cab8b733d48174016b845f8d53">intersect</a>(<span class="keyword">const</span> <a class="code" href="struct_ray.html">Ray</a> ray, float2* uv, <span class="keywordtype">float</span>* t) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">   <span class="comment">// map a (prim,uv) pair to a surface element and compute the corresponding edf/pdf</span></div><div class="line">   <span class="comment">//</span></div><div class="line">   <span class="comment">// \param prim_id       the input primitive index, in case the light is made of a mesh</span></div><div class="line">   <span class="comment">// \param uv            the input uv coordinates on the sampled primitive</span></div><div class="line">   <span class="comment">// \param geom          the output sample&#39;s differential geometry</span></div><div class="line">   <span class="comment">// \param pdf           the output sample&#39;s area pdf</span></div><div class="line">   <span class="comment">// \param edf           the output sample&#39;s EDF</span></div><div class="line">   <span class="comment">//</span></div><div class="line">   FERMAT_HOST_DEVICE</div><div class="line">   <span class="keywordtype">void</span> <a class="code" href="group___lights_module.html#gaf14a70f7d23b422f8953bc55d1eade44">map</a>(<span class="keyword">const</span> uint32_t prim_id, <span class="keyword">const</span> <a class="code" href="structcugar_1_1_vector.html">cugar::Vector2f</a>&amp; uv, <a class="code" href="struct_vertex_geometry.html">VertexGeometry</a>* geom, <span class="keywordtype">float</span>* pdf, <a class="code" href="struct_edf.html">Edf</a>* edf) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">   <span class="comment">// map a (prim,uv) pair and a (precomputed) surface element to the corresponding edf/pdf</span></div><div class="line">   <span class="comment">//</span></div><div class="line">   <span class="comment">// \param prim_id       the input primitive index, in case the light is made of a mesh</span></div><div class="line">   <span class="comment">// \param uv            the input uv coordinates on the sampled primitive</span></div><div class="line">   <span class="comment">// \param geom          the input sample&#39;s differential geometry</span></div><div class="line">   <span class="comment">// \param pdf           the output sample&#39;s area pdf</span></div><div class="line">   <span class="comment">// \param edf           the output sample&#39;s EDF</span></div><div class="line">   <span class="comment">//</span></div><div class="line">   FERMAT_HOST_DEVICE</div><div class="line">   <span class="keywordtype">void</span> <a class="code" href="group___lights_module.html#gaf14a70f7d23b422f8953bc55d1eade44">map</a>(<span class="keyword">const</span> uint32_t prim_id, <span class="keyword">const</span> <a class="code" href="structcugar_1_1_vector.html">cugar::Vector2f</a>&amp; uv, <span class="keyword">const</span> <a class="code" href="struct_vertex_geometry.html">VertexGeometry</a>&amp; geom, <span class="keywordtype">float</span>* pdf, <a class="code" href="struct_edf.html">Edf</a>* edf) <span class="keyword">const</span>;</div><div class="line">};</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>Currently, the only supported EDF model is a simple lambertian emitter, with an interface analogous to the <a class="el" href="struct_bsdf.html">Bsdf</a> class (following Veach's recommended practice of treating sources and sensors as scattering events, assuming the incident direction to an EDF is a <em>virtual source vector</em> where all light comes from, see Chapter 8.3.2.1, pp. 235-237 in his <a href="http://graphics.stanford.edu/papers/veach_thesis/">thesis</a>).</dd></dl>
<p>Next: <a class="el" href="_r_t_context_page.html">Ray Tracing Contexts</a> </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
